//============================================================================
// Name        : MultiAngleFLIC.cpp
// Author      : Matthew Paszek
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include "MultiAngleFLIC.h"

using namespace std;

#define PI 3.14159265				//PI
#define DTR 2*PI/360				//Conversion factor from degrees to radians
#define RTD 360/2/PI				//Conversion factor from radians to degrees

static int mode;					//A control flag for program execution.
static string Dye;					//The membrane dye used.  Currently can be either "DiO, "DiI," "mCherry," or "Custom"
static int orientation;				//0 if the dye is randomly oriented in a complex and 1 if the dye has a specific orientation, such as DiO/DiI in membranes
static double thetaDye;				//The dye excitation dipole angle (usually pi/2 for DiI/DiO in cells)
static string model;  				//The type of sample being imaged.  Choices are "Membrane," "Point," "Cylinder," or "Sphere"
static double length; 				//The length of the verticle cylinder of fluorophers in the 'Cylinder' model.
static double radius; 				//The radius of the fluorescent sphere in the 'Sphere' model.
static double n2;					//The refractive index of the ambient media / cytoplasm
static double nm = 1.4;				//The refractive index of the cell membrane
static double ng = 1.45;			//The refractive index of the cell membrane / SiO2 gap
static double n1;					//The refractive index of SiO2
static complex<double> n0;			//The refractive index of Si
static double dm = 4;				//The thickness of the cell membrane in units of nm
static double d1;					//The thickness of the SiO2 layer
static double lambdaEx; 			//The wavelength of the microscope excitation laser
static double lambdaEmMin; 			//The minimum wavelength of the microscope emission filter
static double lambdaEmMax;			//The maximum wavelength of the microscope emission filter
static double thetaObjMax;			//Maximum angle of light collected by the objective (linked to objective NA)
static double Obj_NA;				//The numerical aperature of the objective
static double Obj_RI;				//The refractive index of the objective's immersion media
static double zGapMin; 				//The minimum gap thickness for which FLIC curves are constructed
static double zGapMax; 				//The maximum gap thickness for which FLIC curves are constructed
static double zGapSpacing;			//The desired sampling rate of points on the FLIC curve
static int FLIC_points; 			//The number of sampled points on the FLIC curve
static double zGap_derivStep = 0.025;
static int usePem;					//0 do not use Pem in FLIC curve calculations, 1 - use Pem in FLIC curve calculations
static string data_source ("Image");		//The FLIC data source - Image or Array
static string ref_source ("Image"); //The Reference data source - Image or Array
static int num_angles; 				//The number of images for each sample
static vector<double> thetaLaser;	//The laser inclination angle (in radians) for each ima
static int polarized;				//0 indicates the laser light is non-polarized or circularly polarized, 1 indicates its linearly polarized
static double thetaPol;				//Polarization angle of the laser light (if linearly polarized) with respect to the plane of incidence
static int reference = 0;  			//If 0 the laser intensities are not corrected by the ref_I factor
static vector<double> ref_I;    	//Reference intensity for each laser angle
static double imageCamera = 0.0;    //Camera background for the main images
static double refCamera = 0.0;    //Camera background for the reference images
static int background = 0;			//Flag that indicates if background images are provided (0 if no background subtraction, 1 if background subtraction)
static int threshold = 0;			//Flag that indicates if threshold image is provided (0 if no threshold image, 1 if threshold image)
static int ref_threshold = 0;		//Flag that indicates if a threshold image is provided for the reference images (0 if no threshold image, 1 if threshold image)
static int num_ref_sets = 0;		//The number of reference image sets.  Each set will contain one image for each angle in the series
static int process_integer = 0;		//Indicates the integer value in the threshold image of a pixel that will be processed
static int ref_process_integer = 0;	//Indicates the integer value in the reference threshold image of a pixel that will be processed
static int seq_start_num; 			//The first number of the image to be analyzed in a sequence
static int num_angle_stacks; 		//The number of sets of flic images per sample point
static char solver;					//The solver type - either local (pixel-wise fit) or global (multi-pixel fits)
static int usecurves;				//Control parameter that dictates whether or not FLIC curves are interpolated to speed up fitting algorithm
static int constraint;				//1 if the local fitting algorithm is constrained, 0 otherwise
static int startCol;				//The starting pixel column for the local fitting algorithm
static int startRow;				//The starting row for the constrained local fitting algorithm
static double maxDisplacement;		//Maximum pixel to pixel height variation
static int nPixtoFitGlobally; 		//The number of randomly selected pixels that will be globally fit to calculate the best
									//fit A and B
static string fit;			//The model parameters to be fit:  HAB, HABL, or HoAB
static double A_guess; 				//The initial guess of the scaling parameter for the height fitting algorithm
static double B_guess; 				//The initial guess of the background parameter for the height fitting algorithm
static double H_guess;				//The initial guess for the height
static double L_guess;				//The initial guess for the length parameter in 4-parameter models
static double H_min;				//The minimum possible height in the fitting algorithm
static double H_max;				//The maximum possible height in the fitting algorithm
static double A_min;				//The minimum possible scaling parameter in the fitting algorithm
static double A_max;				//The maximum possible scaling parameter in the fitting algorithm
static double B_min;				//The minimum possible background constant in the fitting algorithm
static double B_max;				//The maximum possible background constant in the fitting algorithm
static double L_min;				//The minimum possible value for the length parameter in 4-parameter fits
static double L_max;				//The maximum possible value for the length parameter in 4-parameter fits
static double I_cutoff;				//The maximum pixel intensity.  Pixels with greater intensity are not processed
static int MS_step;					//The sampling rate for initial height guesses in the multi-start method in the
									//fitting algorithm
static int surface;  				//Value indicates whether or not the surface algorithm will be call -
									//If 0 the algorithim is not called, if 1 the algorithm will be called
double smoothness;					//Smoothness parameter for the surface algorithm
char interp;						//Interpolation method for the surface algorithm
char regularizer;					//Regularization method for the surface algorithm
double xinc;						//The x grid spacing for the surface algorithm
double yinc;						//The y grid spacing for the surface algorithm
double S_min;						//The minimum height of a pixel location for that pixel to be included in the surface smoothing algorithm
double S_max;						//The maximum height of a pixel location for that pixel to be included in the surface smoothing algorithm
int S_nrows;						//The number of rows in the original image that the surface algorithm will be used on
int S_ncols;						//The number of columns in the original image that the surface algorithm will be used on

double maxForGrad = 250;
double minForGrad = 40;

static int nthreads;				//The desired number of threads for parallel algorithms
static int report;					//Flag that indicates level of reporting to the terminal - 0 (minimal) or 1 (maximal)

static string image_name ("pax8hrWhole01"); //The base name of the main image files (should not include the image sequence #)
static string image_file_ext;		//The file extension on the image files.

//Emission spectra for some commonly used dyes
static double DiO_Lam [] = {475.0,476.0,477.0,478.0,479.0,480.0,481.0,482.0,483.0,484.0,485.0,486.0,487.0,488.0,489.0,
		490.0,491.0,492.0,493.0,494.0,495.0,496.0,497.0,498.0,499.0,500.0,501.0,502.0,503.0,504.0,505.0,506.0,
		507.0,508.0,509.0,510.0,511.0,512.0,513.0,514.0,515.0,516.0,517.0,518.0,519.0,520.0,521.0,522.0,523.0,
		524.0,525.0,526.0,527.0,528.0,529.0,530.0,531.0,532.0,533.0,534.0,535.0,536.0,537.0,538.0,539.0,540.0,
		541.0,542.0,543.0,544.0,545.0,546.0,547.0,548.0,549.0,550.0,551.0,552.0,553.0,554.0,555.0,556.0,557.0,
		558.0,559.0,560.0,561.0,562.0,563.0,564.0,565.0,566.0,567.0,568.0,569.0,570.0,571.0,572.0,573.0,574.0,
		575.0,576.0,577.0,578.0,579.0,580.0,581.0,582.0,583.0,584.0,585.0,586.0,587.0,588.0,589.0,590.0,591.0,
		592.0,593.0,594.0,595.0,596.0,597.0,598.0,599.0,600.0,601.0,602.0,603.0,604.0,605.0,606.0,607.0,608.0,
		609.0,610.0,611.0,612.0,613.0,614.0,615.0,616.0,617.0,618.0,619.0,620.0,621.0,622.0,623.0,624.0,625.0,
		626.0,627.0,628.0,629.0,630.0,631.0,632.0,633.0,634.0,635.0,636.0,637.0,638.0,639.0,640.0,641.0,642.0,
		643.0,644.0,645.0,646.0,647.0,648.0,649.0};

static double DiO_Em [] = {3.0,3.3,3.6,3.9,4.227634,4.334085,4.851135,5.596293,6.610907,7.863134,9.405489,11.28668,
		13.40097,15.98194,19.05524,22.77534,27.03101,31.90448,37.41,43.53095,49.96317,56.63301,63.31234,69.79446,
		75.69918,81.00748,86.12807,90.85423,94.7511,97.44565,99.2824,100,99.68635,98.55293,96.68528,94.12617,
		90.6974,87.44446,84.21765,80.97185,77.59059,74.24023,71.12748,68.00285,64.98753,62.23357,59.8503,57.75217,
		56.1554,54.78437,53.83153,52.85732,51.91874,51.17025,50.49543,49.99406,49.2432,48.51135,47.77474,47.14744,
		46.57954,45.94749,45.41285,44.7713,44.14875,43.3171,42.4902,41.54687,40.69621,39.55566,38.5458,37.30545,
		36.26233,35.10277,34.16419,33.09731,32.10408,30.88274,29.78258,28.72995,27.77474,26.8623,25.93561,25.18712,
		24.45527,23.69752,22.84876,22.14376,21.41975,20.88559,20.2407,19.75288,19.13865,18.5496,17.92634,17.40596,
		16.83474,16.35286,15.8351,15.43804,15.05738,14.70595,14.37401,14.01758,13.6393,13.2931,12.98277,12.64013,
		12.30557,11.99002,11.76809,11.48224,11.1769,10.8661,10.63918,10.40109,10.13591,9.806819,9.541405,9.298563,
		9.076156,8.735892,8.468575,8.179874,7.955328,7.688012,7.484852,7.260307,7.031009,6.801236,6.58168,6.355471,
		6.096947,5.870738,5.644529,5.474397,5.29286,5.13247,4.915528,4.720209,4.546513,4.415112,4.272069,4.150648,
		3.983367,3.860283,3.712249,3.598432,3.48105,3.343472,3.235119,3.102768,3.026494,2.960675,2.928359,2.844244,
		2.75894,2.654865,2.572651,2.513485,2.41131,2.355637,2.263206,2.265962,2.195248,2.147963,2.063205,2.018296,
		1.934656,1.875252,1.810621,1.799857,1.775858,1.777284,1.774979};

static int DiO_elements = 175;

static double DiI_Lam [] = {530.0,531.0,532.0,533.0,534.0,535.0,536.0,537.0,538.0,539.0,540.0,541.0,542.0,543.0,544.0,545.0,
		546.0,547.0,548.0,549.0,550.0,551.0,552.0,553.0,554.0,555.0,556.0,557.0,558.0,559.0,560.0,561.0,562.0,563.0,
		564.0,565.0,566.0,567.0,568.0,569.0,570.0,571.0,572.0,573.0,574.0,575.0,576.0,577.0,578.0,579.0,580.0,581.0,
		582.0,583.0,584.0,585.0,586.0,587.0,588.0,589.0,590.0,591.0,592.0,593.0,594.0,595.0,596.0,597.0,598.0,599.0,
		600.0,601.0,602.0,603.0,604.0,605.0,606.0,607.0,608.0,609.0,610.0,611.0,612.0,613.0,614.0,615.0,616.0,617.0,
		618.0,619.0,620.0,621.0,622.0,623.0,624.0,625.0,626.0,627.0,628.0,629.0,630.0,631.0,632.0,633.0,634.0,635.0,
		636.0,637.0,638.0,639.0,640.0,641.0,642.0,643.0,644.0,645.0,646.0,647.0,648.0,649.0,650.0,651.0,652.0,653.0,
		654.0,655.0,656.0,657.0,658.0,659.0,660.0,661.0,662.0,663.0,664.0,665.0,666.0,667.0,668.0,669.0,670.0,671.0,
		672.0,673.0,674.0,675.0,676.0,677.0,678.0,679.0,680.0,681.0,682.0,683.0,684.0,685.0,686.0,687.0,688.0,689.0,
		690.0,691.0,692.0,693.0,694.0,695.0,696.0,697.0,698.0,699.0};

static double DiI_Em [] = {2.843224,2.892825,2.926616,2.983924,3.121656,3.309256,3.48109,3.665323,3.954517,4.373206,
		4.946856,5.624003,6.555801,7.733393,9.166076,10.89194,12.85385,15.17715,17.79982,20.71966,23.91408,27.4473,
		31.34721,35.85917,40.58547,46.00974,51.54562,57.65722,63.4411,69.23384,74.56155,79.36227,83.78211,87.62179,
		91.43047,94.41985,96.86005,98.69796,99.83171,100,99.53056,98.31709,97.02834,95.09743,92.85651,90.35873,
		87.29849,84.34455,81.45704,78.53853,75.72188,72.43578,69.35341,66.09832,63.44553,60.86359,58.66696,56.4659,
		54.6147,53.09566,51.47033,49.907,48.38353,47.17892,46.06289,45.14614,44.32241,43.72453,43.16652,42.68822,
		42.34942,41.95084,41.45261,41.35518,41.25731,41.21745,40.9163,40.71568,40.45483,40.07307,39.72808,39.34057,
		38.91187,38.36581,37.76749,37.06599,36.2458,35.39105,34.67804,33.73029,32.82064,31.88087,30.89725,30,28.87865,
		27.94287,26.99513,26.16918,25.33171,24.52613,23.66076,22.86802,21.84012,20.97564,20.12312,19.48228,18.72055,
		17.99247,17.36625,17.00354,16.49513,16.0713,15.34765,14.82152,14.24048,13.85429,13.46457,13.11648,12.73738,
		12.29938,11.97874,11.62622,11.51506,11.17405,11.05226,10.72498,10.5403,10.25332,10.08503,9.910983,9.777679,
		9.64969,9.488485,9.238707,9.114703,8.984056,8.846324,8.591231,8.328167,8.146589,7.930469,7.841452,7.779008,
		7.618689,7.348095,7.084145,7.035872,6.820195,6.622675,6.357396,6.22365,5.986714,5.813995,5.633304,5.551816,
		5.40744,5.389725,5.300266,5.062445,4.857839,4.722764,4.692648,4.624003,4.446413,4.340567,4.232507,4.236935,
		4.161515,4.008547,3.734278};

static int DiI_elements = 170;

static double mCherry_Lam [] = {550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,
		579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,
		608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,
		637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,
		666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,
		695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,
		724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,
		753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,
		782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800};

static double mCherry_Em []	= {0.001,0.001,0.002,0.002,0.002,0.003,0.003,0.004,0.004,0.005,0.006,0.009,0.016,0.025,0.029,0.026,0.020,0.019,0.022,0.026,
		0.030,0.034,0.042,0.048,0.055,0.065,0.075,0.089,0.102,0.119,0.138,0.160,0.183,0.211,0.237,0.265,0.297,0.335,0.369,0.406,
		0.447,0.488,0.531,0.571,0.613,0.655,0.692,0.733,0.767,0.808,0.839,0.869,0.896,0.920,0.937,0.961,0.974,0.980,0.989,0.996,
		1.000,0.990,0.991,0.976,0.968,0.955,0.942,0.931,0.903,0.892,0.871,0.852,0.830,0.812,0.795,0.772,0.754,0.739,0.719,0.706,
		0.690,0.674,0.662,0.650,0.633,0.616,0.605,0.596,0.582,0.576,0.562,0.554,0.543,0.538,0.535,0.521,0.514,0.503,0.499,0.489,
		0.483,0.477,0.471,0.462,0.455,0.452,0.440,0.433,0.423,0.416,0.413,0.406,0.400,0.392,0.386,0.378,0.371,0.365,0.359,0.354,
		0.350,0.340,0.336,0.329,0.320,0.314,0.309,0.305,0.297,0.286,0.279,0.276,0.268,0.260,0.252,0.247,0.240,0.232,0.231,0.225,
		0.217,0.206,0.207,0.198,0.195,0.190,0.185,0.180,0.176,0.169,0.167,0.163,0.158,0.154,0.149,0.145,0.142,0.142,0.136,0.135,
		0.128,0.126,0.124,0.122,0.120,0.116,0.111,0.110,0.106,0.104,0.102,0.100,0.097,0.096,0.094,0.092,0.089,0.087,0.086,0.083,
		0.081,0.079,0.077,0.078,0.073,0.075,0.071,0.073,0.068,0.067,0.066,0.066,0.061,0.063,0.060,0.061,0.057,0.056,0.056,0.056,
		0.054,0.051,0.052,0.050,0.050,0.048,0.045,0.046,0.044,0.043,0.040,0.041,0.040,0.040,0.039,0.036,0.038,0.037,0.034,0.033,
		0.034,0.033,0.032,0.031,0.030,0.029,0.030,0.030,0.027,0.026,0.027,0.025,0.025,0.026,0.024,0.024,0.023,0.022,0.022,0.022,
		0.020,0.021,0.020,0.020,0.018,0.017,0.020,0.018,0.017,0.016,0.017};

static int mCherry_elements = 251;

static double TFP_Lam [] = {0};

static double TFP_Em []	= {0};

static int TFP_elements = 1;

static double YFP_Lam [] = {0};

static double YFP_Em []	= {0};

static int YFP_elements = 1;

static double CFP_Lam [] = {0};

static double CFP_Em []	= {0};

static int CFP_elements = 1;

static double Alexa488_Lam [] = {475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,
		499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,
		530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,
		561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,
		592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,
		623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,
		654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675};

static double Alexa488_Em [] = {0.979202,0.7017655,0.4852089,0.4840133,0.5698063,0.7110866,0.860956,1.069875,1.345994,1.668182,2.103955,
		2.581697,3.224486,3.944527,4.848526,5.912594,7.095542,8.524304,10.20722,12.18995,14.54477,17.12979,20.15777,23.53367,27.22775,31.25619,
		35.50921,40.04907,44.65386,49.65947,54.46586,59.60864,64.62728,69.77808,74.2916,79.11359,83.07986,86.77189,90.17967,92.87098,95.06226,
		96.95232,98.43452,99.46811,99.82077,100,99.61855,98.58117,97.27509,95.98027,94.28366,92.25999,90.39438,88.15095,85.96471,83.3491,80.76096,
		78.2592,75.45985,72.62863,70.0626,67.64776,65.06199,62.91389,60.53472,58.3782,56.18806,54.14721,52.26948,50.57441,48.9867,47.20159,45.73164,
		44.16367,42.74208,41.27572,40.0446,38.73765,37.65509,36.46091,35.37452,34.30606,33.2388,32.29171,31.38754,30.29636,29.28731,28.36565,27.50599,
		26.58718,25.79486,25.07528,24.25486,23.29783,22.4909,21.94921,21.06648,20.30616,19.48712,18.80446,18.15909,17.39656,16.72586,16.13629,
		15.49738,14.92194,14.26831,13.58558,12.9392,12.52339,11.93687,11.55976,11.1366,10.64905,10.29346,9.893942,9.468491,9.108702,8.730515,8.403642,
		8.075037,7.736989,7.423903,7.204468,6.877082,6.693296,6.419983,6.2086,6.008928,5.747986,5.592822,5.389613,5.110127,5.009059,4.797871,4.645317,
		4.523728,4.332036,4.204493,4.05372,3.892725,3.78197,3.636761,3.573026,3.407589,3.304398,3.133739,3.049361,2.89671,2.794667,2.688767,2.586186,
		2.439099,2.394738,2.279786,2.167665,2.108932,2.040317,1.971288,1.924316,1.859947,1.827836,1.693558,1.673745,1.584877,1.559769,1.494936,1.449404,
		1.420807,1.387061,1.312907,1.256346,1.215865,1.184193,1.170284,1.102231,1.063897,1.056992,1.010972,0.9797145,0.9391603,0.9019005,0.8845759,
		0.8243549,0.8167662,0.7988073,0.7606689,0.729558,0.7169916,0.7080365,0.6980078,0.6610407,0.6739731,0.6196326,0.6103847,0.6104335,0.6017713,
		0.555727,0.5344008,0.5249089,0.5088044};

static int Alexa488_elements = 201;

static double Alexa568_Lam [] = {555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,
		579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,
		608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,
		637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,
		666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,
		695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,
		724,725};

static double Alexa568_Em [] = {3.538162,2.722276,2.00584,1.996602,2.110362,2.471931,2.885671,3.224416,3.713694,4.334122,4.997663,5.640554,6.544477,7.558719,
		8.514269,9.82849,10.90052,12.31672,14.12874,15.73279,18.62734,20.82339,23.72409,27.04578,30.01623,33.52052,37.09364,40.701,44.37339,48.52039,53.2322,
		56.55716,60.61285,65.04915,68.58694,72.44846,76.80015,79.79831,83.22598,87.19762,89.70035,92.39654,93.9716,95.75265,96.77595,98.2916,99.07742,99.34026,
		100,99.38699,98.55427,97.17103,95.91151,94.23862,93.49284,91.29372,88.66292,87.07444,84.44074,82.13348,80.02003,77.32185,75.34119,72.48921,70.00116,
		67.83555,65.09425,62.35639,60.16905,58.10723,56.17638,54.80203,52.59511,50.88418,48.75154,47.54763,45.55592,44.07867,43.24902,41.45204,40.31987,
		38.91037,37.83254,37.02535,35.6345,34.60903,33.30024,32.85154,32.33292,31.5558,30.78393,30.29302,29.23839,29.35686,28.28845,27.51079,27.46242,26.74562,
		26.15853,25.14628,24.47495,24.66678,23.66939,23.97353,23.22974,23.10729,22.40244,22.56602,22.19847,21.37262,21.16286,20.52413,20.20096,19.83505,19.26118,
		18.90739,18.13444,18.07049,17.87866,17.57868,16.54361,16.30033,15.44731,14.90115,14.57671,14.46857,14.057,13.69109,12.98479,12.17652,11.72075,11.51968,
		11.23274,10.79418,10.26415,10.30962,9.67524,9.407323,8.869317,8.99449,8.527131,8.671323,7.936772,7.976806,8.022999,7.684435,7.093534,6.91456,6.781054,
		6.498647,6.114977,6.114615,5.959553,5.902854,5.70631,5.091679,5.280071,5.100374,5.103997,5.015597,5.014328,4.753296,4.459476,4.523964,4.374518,4.613451,
		4.545158,4.231955,4.179966,4.170184,3.964945};

static int Alexa568_elements = 171;

static double Alexa594_Lam [] = {580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,
		608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,
		637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,
		666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,
		695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,
		724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750};

static double Alexa594_Em [] = {6.159652,6.657252,7.393682,8.439029,9.697656,11.0455,12.52446,14.19956,16.21023,18.36772,20.67448,23.06124,25.72563,28.82137,31.39201,34.48686,37.65972,
		41.22657,44.79509,48.51176,52.36294,56.10341,59.79898,63.7296,67.78604,71.54912,74.81172,78.44492,81.79675,84.75771,87.60434,90.36494,92.63379,94.40963,
		95.86674,97.46132,98.5704,99.58007,100,99.82571,99.60434,99.47138,98.47868,97.6152,96.81441,95.33356,93.43191,91.77079,89.87393,88.16347,85.91565,84.12842,
		81.89742,79.76271,77.06181,74.86134,72.83564,70.24368,67.88036,65.78358,63.6376,61.58537,59.49122,57.66385,55.54511,53.62628,52.26034,50.51135,48.88625,
		47.27924,45.80135,44.53698,43.27085,42.0849,40.80254,39.76564,38.83087,37.70473,37.06108,36.12849,35.35397,34.63075,34.16343,33.4713,32.6449,32.10725,31.58802,
		30.96013,30.23204,29.76477,28.91156,28.51897,28.09375,27.64659,26.89773,26.57753,26.15461,25.553,25.07635,24.57134,24.15125,23.70088,23.18129,22.63349,
		22.18079,21.75091,21.26381,20.66264,20.10799,19.6894,19.32303,18.72565,18.39428,17.80299,17.46973,16.96676,16.58983,16.25421,15.8811,15.22661,14.91386,14.38712,
		13.97341,13.52077,13.00403,12.51318,12.24539,11.8706,11.48916,10.98058,10.65321,10.24641,10.03522,9.651175,9.36594,9.011077,8.51892,8.315224,8.065984,7.658446,
		7.36029,7.313755,7.034952,6.722994,6.35893,6.191506,6.046386,5.854695,5.79458,5.538778,5.463121,5.323188,5.202738,5.112418,4.845291,4.817102,4.67255,4.586245,
		4.398238,4.363708,4.170607,4.089836,4.061226,3.97734,3.864513,3.820215,3.751669,3.572405,3.574366,3.524642,3.403642};

static int Alexa594_elements = 171;

static double Cy3_Lam [] = {500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,
		530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,
		561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,
		592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,
		623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,
		654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,
		685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,
		716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,
		747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,
		778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800};

static double Cy3_Em [] = {0.62384028,0.677922989,0.714385752,0.715087905,0.779116334,0.830749519,0.859716969,0.90864374,0.921126675,0.941894136,1.028098748,
		1.025323571,1.048937496,1.053668357,1.052259634,1.079870092,1.095819002,1.079283387,1.114949367,1.136831566,1.136169158,1.127914283,1.174207822,1.206379438,
		1.196662848,1.255592622,1.296069582,1.362669419,1.436401821,1.55181235,1.631131066,1.805693435,1.962589047,2.186861722,2.483398775,2.831621375,3.250994875,
		3.84521211,4.467893994,5.16303898,6.113149508,7.317566323,8.707937045,10.37740896,12.25607587,14.63616096,17.51280657,20.61612845,24.63418004,28.82661546,
		33.51286713,38.29568538,44.07806582,50.08823915,56.24651447,62.17790532,68.40341828,73.83662098,79.57137738,84.67526831,88.716214,92.85431297,95.41222012,
		97.64781809,99.09943954,99.95577633,100,99.01395727,97.93107669,95.92038225,93.35212892,90.84500645,88.11058315,84.41194506,81.16601603,77.55582529,73.85592547,
		70.86751573,67.32072696,63.87380419,60.90545598,58.20496693,55.44928346,52.81034796,50.55261292,48.35221724,46.10596395,44.18215862,42.4655926,40.94441192,
		39.51181737,38.44641807,37.0490132,36.33636233,35.55309238,34.79813567,34.23961154,33.84409674,33.3362942,32.9388174,32.58599958,32.35927915,31.97956122,
		31.79130466,31.65294324,31.08161885,30.78885942,30.4919552,30.08989833,29.59643536,29.11568433,28.36991932,27.87892935,27.22320147,26.20772886,25.78195144,
		24.8791451,24.08043787,23.09657162,22.24681476,21.529874,20.66159493,19.71857722,18.96254173,18.07542501,17.38414786,16.54608094,15.79988064,15.01400521,
		14.33737045,13.6489322,12.96248117,12.44180897,11.77947593,11.33715722,10.81334331,10.2498795,9.724690308,9.272631037,8.892932036,8.527496902,8.156554314,
		7.806707866,7.524193691,7.201083322,6.960673108,6.604423376,6.331542517,6.145509752,5.931062176,5.658713766,5.437736101,5.262974379,5.155722833,4.897185331,
		4.717965282,4.562445588,4.468769005,4.204338588,4.107645837,3.978501997,3.802628059,3.726851022,3.53794088,3.478918999,3.300807382,3.220548676,3.051436355,
		3.004751048,2.871972161,2.771650041,2.61075285,2.573249159,2.438319652,2.342390879,2.220827519,2.140456519,2.080610728,1.939957379,1.866049596,1.810997121,
		1.721968124,1.692084026,1.532907205,1.487351147,1.423221149,1.359594581,1.310531542,1.282286433,1.240002675,1.152961535,1.108243898,1.054125103,1.058420035,
		1.000713509,0.926894047,0.926432254,0.850846369,0.830583601,0.820451902,0.788563545,0.772538931,0.731641184,0.713670981,0.667061378,0.640922729,0.603635299,
		0.548711773,0.537621978,0.534362674,0.484618301,0.504211469,0.431456025,0.45327987,0.417232721,0.393046916,0.40062216,0.366002344,0.356133148,0.321652186,
		0.293389224,0.302081604,0.29204548,0.294390849,0.274847709,0.254284334,0.250609984,0.259051595,0.234831723,0.210544033,0.214530724,0.201313399,0.205661891,
		0.198743001,0.181313512,0.180768003,0.18214657,0.163316939,0.157667665,0.148523018,0.142584555,0.145305288,0.135806347,0.14106133,0.119972696,0.133958227,
		0.117936136,0.111833459,0.101758538,0.110078076,0.099941708,0.102157623,0.096080307,0.094506676,0.08424792,0.095658384,0.088685049,0.073721867,0.072352447,
		0.077936363,0.063649721,0.061358133,0.060320713,0.053477457,0.060690306,0.064583465,0.050729489,0.05230833,0.059399832,0.049076022,0.045960758,0.048577159,
		0.049161662,0.045931492,0.046713979,0.038952366,0.046607401,0.038323961,0.035414428,0.041817101,0.029880918,0.036610196,0.037177483,0.026455527,0.027604269,
		0.029362081,0.032252947,0.026483045,0.028538152,0.019753142,0.027880399,0.028772058,0.024641246,0.02413256,0.018594634,0.024713871,0.020887363,0.014793732,
		0.016787601,0.021522278,0.01707474};

static int Cy3_elements = 301;

static double Cy5_Lam [] = {600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,
		623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,
		654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,
		685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,
		716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,
		747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,
		778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800};

static double Cy5_Em [] = {1.021764854,1.050078393,1.093728433,1.106705472,1.08900951,1.152714973,1.078391933,1.110244664,1.13265955,1.143277127,1.160973089,1.251812361,
		1.182208244,1.240015053,1.163332551,1.349730019,1.40989629,1.462984176,1.506634216,1.638764067,1.724884416,1.868811575,2.06700635,2.208574048,2.35839986,2.668669063,
		2.906974687,3.237299313,3.506277938,4.039516263,4.648257361,5.062342875,5.891693633,6.64436189,7.530339727,8.644005611,9.972382502,11.13559708,13.11872457,14.73023685,
		16.63196292,18.53368898,21.33908885,23.95809124,26.88382365,29.78950063,33.13049828,36.96344368,40.65836058,44.94668207,49.43083887,53.47613582,57.41643672,62.38310342,
		66.68794115,71.29950888,75.61142499,79.81952478,83.81055411,86.64190805,90.38991283,92.75409337,94.64402213,96.47968327,98.46163103,98.86981788,100,98.82026919,
		98.55482976,97.29133806,95.32708627,93.80759298,91.78435465,88.98131424,85.7594694,83.19827382,79.46088661,75.89338065,72.46390319,68.78314306,65.07642886,61.68116359,
		58.1242752,55.43920788,52.56774309,48.9801817,46.53577947,44.10907319,41.22699083,38.74719666,35.96067249,34.14152759,32.2810921,30.43953231,28.70178883,27.19999151,
		25.42567637,24.01471832,22.54477373,21.52194712,20.50501916,19.55533586,18.76137703,18.0098885,16.96582674,16.12939759,15.69171746,15.32836037,14.42586631,13.99172537,
		13.52219251,12.99957176,12.71879583,12.34600089,11.80332472,11.37626216,11.14739439,10.77223999,10.57758441,10.39590586,9.883902691,9.958225732,9.6927863,9.390775213,
		9.132414166,9.043934355,9.013261354,8.81742604,8.621590725,8.29244583,8.036444244,7.712018272,7.780442659,7.420624762,7.204734024,7.064346058,6.875589128,6.618407812,
		6.330553494,6.186626336,6.019104561,5.797315169,5.575525777,5.311266075,5.122509146,4.898360292,4.828756174,4.518486972,4.48663424,4.115019035,4.054852764,3.859017449,
		3.625430749,3.490941437,3.358811586,3.196008735,3.080395115,2.906974687,2.588447368,2.646254178,2.545977059,2.371376899,2.325367398,2.176721316,1.998581964,1.875889959,
		1.903023768,1.860553459,1.748479032,1.641123528,1.571519411,1.527869371,1.529049102,1.432311175,1.341471903,1.258890746,1.265969131,1.145636589,1.164512282,1.018225661,
		1.073673009,1.13265955,1.009967546,0.927386389,0.921487735,0.880197157,0.864860656,0.779920038,0.786998423,0.746887575,0.801155192,0.709136189,0.723292959,0.639532072,
		0.653688841,0.60767934,0.632453687,0.558130646,0.574646877,0.552231992,0.553411723};

static int Cy5_elements = 201;

static double eGFP_Lam [] = {463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,
		489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,
		520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,
		551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,
		582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,
		613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,
		644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,
		675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700};

static double eGFP_Em [] = {0.003,0.003,0.003,0.004,0.004,0.005,0.006,0.007,0.009,0.010,0.012,0.015,0.018,0.022,0.027,0.032,0.038,0.046,0.055,0.065,0.078,0.092,0.109,0.127,
		0.148,0.172,0.198,0.227,0.259,0.295,0.331,0.371,0.416,0.460,0.509,0.559,0.610,0.665,0.718,0.767,0.816,0.862,0.903,0.935,0.966,0.988,0.999,1.000,1.000,0.989,0.970,
		0.941,0.906,0.871,0.834,0.793,0.751,0.715,0.680,0.650,0.621,0.597,0.570,0.547,0.528,0.508,0.490,0.473,0.464,0.450,0.439,0.430,0.422,0.410,0.401,0.394,0.387,0.381,
		0.369,0.362,0.358,0.348,0.339,0.330,0.322,0.312,0.302,0.291,0.280,0.267,0.256,0.245,0.234,0.224,0.216,0.207,0.196,0.186,0.181,0.171,0.162,0.155,0.149,0.141,0.135,
		0.128,0.122,0.117,0.114,0.108,0.104,0.097,0.096,0.092,0.088,0.084,0.081,0.079,0.076,0.074,0.071,0.069,0.065,0.064,0.063,0.059,0.059,0.056,0.054,0.053,0.050,0.049,
		0.047,0.046,0.044,0.042,0.041,0.039,0.037,0.036,0.036,0.034,0.032,0.032,0.030,0.029,0.028,0.027,0.026,0.025,0.024,0.022,0.022,0.022,0.021,0.020,0.019,0.018,0.018,
		0.017,0.017,0.016,0.015,0.015,0.015,0.015,0.014,0.013,0.014,0.013,0.013,0.012,0.012,0.012,0.011,0.011,0.011,0.011,0.010,0.010,0.010,0.010,0.010,0.010,0.009,0.010,
		0.009,0.009,0.008,0.008,0.008,0.008,0.008,0.008,0.008,0.008,0.008,0.007,0.008,0.008,0.007,0.007,0.007,0.007,0.007,0.007,0.007,0.006,0.007,0.007,0.006,0.007,0.006,
		0.007,0.007,0.007,0.007,0.006,0.007,0.006,0.007,0.007,0.007,0.007,0.006,0.007,0.006,0.007,0.006,0.007,0.007,0.006,0.006,0.006,0.007,0.007,0.006,0.006};

static int eGFP_elements = 238;


//Interpolarots for the FLIC Curves,static gsl_interp_accel *spectra_acc;
static gsl_interp_accel *spectra_acc;
static gsl_spline *spectra_spline;

static gsl_interp_accel *FLIC_acc;
static gsl_spline *FLIC_spline;

static gsl_interp_accel *DERIV_acc;
static gsl_spline *DERIV_spline;


int main(int argc, char **argv)
{



	//Generate a ref image from a series
	//generateAveragedRefSeries("/home/weaver/Desktop/threshold/", "zoomfitcref", 27, 11);
	//return 0;
	/*
	cout <<"here";

	using namespace Magick;

	//Create some images
	int ii, jj;
	double array [95];
	int num_points = 95;
	int num_images = 24;
    string line1, item1;  //For loading parameters from Parameters.dat
    ifstream inFile1 ("/home/weaver/Desktop/Cell005.csv");
    istringstream linestream1;
    double max1;
	Image new_image( Geometry(num_points, 1), "white");
	new_image.magick("TIFF");
	new_image.modifyImage();

	string image_path1 ("/home/weaver/Desktop/images/");
	string imageName ("Cell005Beads");
	string path1;

	for (jj = 0; jj < num_images; jj++) {
		getline (inFile1, line1);
	    linestream1.clear();
	    linestream1.str(line1);

		for (ii = 0; ii < num_points; ii++) {
			getline (linestream1, item1, ',');
			removeAllWhiteSpaces(item1);
			array[ii] = StrToDouble(item1);
			cout << array[ii] << " ";
		}

		for (ii = 0; ii < num_points; ii++) {
			//array[ii] = array[ii]*MaxRGB/2;
			//array[ii] = array[ii]*2;
		}

		//Write the image to file
		generate_image_seq_path(path1, image_path1, imageName, ".tif", jj);
		for (ii = 0; ii < num_points; ii++)
			new_image.pixelColor(ii,0,Color(array[ii],array[ii],array[ii],0));
		new_image.write(path1);
	}

	cout << "\nDone!\n";

	return 0;
	*/



	//***********************************************The local variables**************************************************
	//Iterators and auxiliary variables
	int i, j, k, counter, flag,  index, row, col, unprocessed;
	int returnFlag = 1;
	char modifier;
	double max, min, val1, val2;
	time_t start;
	double walltime;
	Spectra Spec;

	//File access / storage
	string file_path;
	string name;
	ofstream sfile;
    string line, item;  //For loading parameters from Parameters.dat
    ifstream inFile ("Parameters.dat");
    istringstream linestream;

	//Variables for image storage and description
	MKL_INT num_rows = 0;
	MKL_INT num_cols = 0;
	int thresh_nrows, thresh_ncols;
	int *Images_temp;
	double *Images;
	int* Thresh;
	double intensity;
	vector<double>  data_array;
	double* ref_averages;
	int* nrefs;
	int* ref_thresh;
	int* ref_image;

	//For storage of the FLIC curves
	double *ZGAP, *FLIC, *DERIV;

	//Variables used in the fitting algorithms
    double *XF, *YF, *HF, *H, *R, *A, *B, *L, *G, *AF, *BF, *LF, *RF, *GF, *XS, *YS, *HS;
	double Ho, Ro, Ao, Bo, Lo;
	int *F, *dataPixels;
	MKL_INT nfitPix = 0;
	MKL_INT ngradPix = 0;
	MKL_INT ndataPix = 0;
	int dist, edge_dist;  // get rid of these in the future
	double H_multiplier, HS_multiplier; 		//multiplier used for writing the height data as an image
	double grad, gradX, gradY;

	//Variables that will be used in the for Surface Reconstruction
	MKL_INT xmax, ymax;
	MKL_INT nx = 0;
	MKL_INT ny = 0;
	double *xnodes, *ynodes, *zgrid;

	//*******************************************Load Parameters From Parameters.dat file*******************************************

    //Line 1: Program Mode
    getline (inFile, line);
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    mode = StrToInt(item);

    //Line 2: Dye - fluorophore
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    Dye = item;

    //Line 3: Dye - Orientation
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    orientation = StrToInt(item);

    //Line 4:  Dye - dipole angle
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    thetaDye = StrToDouble(item)*DTR;

    //Line 5: Model - Type
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    model = item;

    //Line 6:  Model - thickness of Si02 layer
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    d1 = StrToDouble(item);

    //Line 7:  Model - Refractive index n1
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    n1 = StrToDouble(item);

    //Line 8 and 9: Refractive index n0, real and complex
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    val1 = StrToDouble(item);
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    val2 = StrToDouble(item);
    n0 = complex<double> (val1, val2);

	//Line 10:  Model (Membrane) - Refractive index ambient media or cytoplasm - n3
	getline (inFile, line);
	linestream.clear();
	linestream.str(line);
	getline (linestream, item, ':');
	getline (linestream, item, ',');
	removeAllWhiteSpaces(item);
	n2 = StrToDouble(item);

    //Line 11: Model (Cylinder) - Sphere radius
    if (model == "Cylinder") {
		getline (inFile, line);
		linestream.clear();
		linestream.str(line);
		getline (linestream, item, ':');
		getline (linestream, item, ',');
		removeAllWhiteSpaces(item);
		length = StrToDouble(item);
    }
    else getline (inFile, line);  //Advance through the parameter file

    //Line 12: Model (Sphere) - Sphere radius
    if (model == "Sphere") {
		getline (inFile, line);
		linestream.clear();
		linestream.str(line);
		getline (linestream, item, ':');
		getline (linestream, item, ',');
		removeAllWhiteSpaces(item);
		radius = StrToDouble(item);
    }
    else getline (inFile, line);  //Advance through the parameter file

    //Line 13: Microscope - excitation wavelength
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    lambdaEx = StrToDouble(item);

    //Line 14: Microscope - Laser Polarization
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    polarized = StrToInt(item);

    //Line 15: Microscope - Laser Polarization Angle
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    thetaPol = StrToDouble(item)*DTR;

    //Line 16:  Microscope - Range of emission wavelengths
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    lambdaEmMin = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    lambdaEmMax = StrToDouble(item);

    //Line 17: Microscope - Objective NA
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    Obj_NA = StrToDouble(item);

    //Line 18: Microscope - Objective NA
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    Obj_RI = StrToDouble(item);

    //Line 19: Curves - Range of FLIC curves
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    zGapMin = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    zGapMax = StrToDouble(item);

    //Line 20:  Curves - Sampling rate of FLIC curves
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    zGapSpacing = StrToDouble(item);
    FLIC_points = floor( (zGapMax-zGapMin)/zGapSpacing ) + 1;

    //Line 21: Curves - FLIC curves derivative step size
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    zGap_derivStep = StrToDouble(item);

    //Line 22: Curves - Use Pem
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    usePem = StrToInt(item);

    //Line 23: Input - number of angles
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    num_angles = StrToInt(item);

    //Line 24: Input - image angles
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    for (i=0; i < num_angles; i++) {
    	getline (linestream, item, ',');
    	removeAllWhiteSpaces(item);
    	thetaLaser.push_back( StrToDouble(item)*DTR );
    	cout << thetaLaser[i]*RTD << " ";
    }

    //Line 25: Input - Angle redundacy
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    num_angle_stacks = StrToInt(item);

    //Line 26: Input - Primary FLIC data source
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    data_source = item;

    //Line 27: Input - FLIC data array
    if (data_source == "Array") {
		getline (inFile, line);
		linestream.clear();
		linestream.str(line);
		getline (linestream, item, ':');
		for (i=0; i < num_angles; i++) {
			getline (linestream, item, ',');
			removeAllWhiteSpaces(item);
			data_array.push_back( StrToDouble(item) );
		}
    }
    else getline (inFile, line);  //Advance through the parameter file


    //Line 28: Input - Data Image Threshold
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    threshold = StrToInt(item);

    //Line 29: Input - Data Image Threshold integer to process
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    process_integer = StrToInt(item);

    //Line 30: Input - Correct intensities
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    reference = StrToInt(item);

    //Line 31: Input - Reference data source
	getline (inFile, line);
	linestream.clear();
	linestream.str(line);
	getline (linestream, item, ':');
	getline (linestream, item, ',');
	removeAllWhiteSpaces(item);
	ref_source = item;

    //Line 32: Input - Reference intensities
    if (ref_source == "Array" && reference != 0) {
		getline (inFile, line);
		linestream.clear();
		linestream.str(line);
		getline (linestream, item, ':');
		for (i=0; i < num_angles; i++) {
			getline (linestream, item, ',');
			removeAllWhiteSpaces(item);
			ref_I.push_back( StrToDouble(item) );
		}
    }
    else getline (inFile, line);  //Advance through the parameter file


    //Line 33: Input - Number of reference sets
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    num_ref_sets = StrToInt(item);

    //Line 34: Input - Reference Threshold
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    ref_threshold = StrToInt(item);

    //Line 35: Input - Reference Threshold integer to process
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    ref_process_integer = StrToInt(item);

    //Line 36: Input - Camera background intensity
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    imageCamera = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    refCamera = StrToDouble(item);

    //Line 37: Input - Background subtraction
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    background = StrToInt(item);

    //Line 38: Input - first number in image sequence
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    seq_start_num = StrToInt(item);

    //Line 39:  Input - file extension
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    image_file_ext = item;

    //Line 40: Fit - HAB or HABL or HoAB or HABC (HABCL - linearly increasing background, HABCQ - Quadratic increasing background)
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    fit = item;

    //Line 41: Fit - A range
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    A_min = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    A_max = StrToDouble(item);

    //Line 42: Fit - B range
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    B_min = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    B_max = StrToDouble(item);

    //Line 43: Fit - H range
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    H_min = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    H_max = StrToDouble(item);

    //Line 44: Fit - L range
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    L_min = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    L_max = StrToDouble(item);

    //Line 45: Fit - A guessnparameters
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    A_guess = StrToDouble(item);

    //Line 46: Fit - B guess
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    B_guess = StrToDouble(item);

    //Line 47: Fit - H guess
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    H_guess = StrToDouble(item);

    //Line 48: Fit - L guess
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    L_guess = StrToDouble(item);

    //Line 49: Fit - multistart step size
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    MS_step = StrToDouble(item);

    //Line 50: Fit - Solver
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    solver = item[0];

    //Line 51: Fit - Constraint
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    constraint = StrToInt(item);

    //Line 52: Fit - Starting column
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    startCol = StrToInt(item);

    //Line 53: Fit - Starting row
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    startRow = StrToInt(item);

    //Line 54: Fit - Maximum height change
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    maxDisplacement = StrToDouble(item);

    //Line 55: Fit - Use curves
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    usecurves = StrToInt(item);

    //Line 56: Surface
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    surface = StrToInt(item);

    //Line 57: Surface - Smoothness
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    smoothness = StrToDouble(item);

    //Line 58: Surface - Interpolation method
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    interp = item[0];

    //Line 59: Surface - Regularizer
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    regularizer = item[0];

    //Line 60: Surface - x increment
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    xinc = StrToDouble(item);

    //Line 61: Surface - y increment
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    yinc = StrToDouble(item);

    //Line 62: Surface - Surface height range
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    S_min = StrToDouble(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    S_max = StrToDouble(item);

    //Line 63: Fit Pixels
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    nfitPix = StrToInt(item);

    //Line 64: Surface - Number of fit rows and columns
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    S_nrows = StrToInt(item);
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    S_ncols = StrToInt(item);

    //Line 65: Threads
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    nthreads = StrToInt(item);

    //Line 66: Report
    getline (inFile, line);
    linestream.clear();
    linestream.str(line);
    getline (linestream, item, ':');
    getline (linestream, item, ',');
    removeAllWhiteSpaces(item);
    report = StrToInt(item);

	//*******************************************Handle command line flags**********************************************
	if (argc > 1) {
		image_name = argv[1];

		for (i = 2; i < argc; i++) {
			if (argv[i][0] == '-') {
				switch (argv[i][1]) {

					case 'X':
						mode = atoi(&argv[i][2]);
						break;

					case 'D':
						if (argv[i][2] == 'F') {
							if (argv[i][3] == 'O') {
								Dye = "DiO";
								break;
							}
							if (argv[i][3] == 'I') {
								Dye = "DiI";
								break;
							}
							if (argv[i][3] == 'C') {
								Dye = "mCherry";
								break;
							}
							if (argv[i][3] == 'X') {
								Dye = "Custom";
								break;
							}
							cout << "\nUnrecognized flag: -DF" << argv[i][3];
							break;
						}
						if (argv[i][2] == 'A') {
							thetaDye = atof(&argv[i][2]);
							break;
						}
						if (argv[i][2] == 'O') {
							orientation = atoi(&argv[i][2]);
							break;
						}



					case 'M':
						if (argv[i][2] == 'T')  {
							model = &argv[i][3];
							break;
						}
						if (argv[i][2] == 'R')  {
							if (argv[i][3] == 'B') {
								n2 = atof(&argv[i][4]);
							}
							if (argv[i][3] == 'O') {
								n1 = atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'S') {
								//String code
								line = &argv[i][4];
							    linestream.clear();
							    linestream.str(line);
							    getline (linestream, item, ',');
							    removeAllWhiteSpaces(item);
							    val1 = StrToDouble(item);
							    getline (linestream, item, ',');
							    removeAllWhiteSpaces(item);
							    val2 = StrToDouble(item);
							    n0 = complex<double> (val1, val2);
								break;
							}
						}
						if (argv[i][2] == 'O') {
							d1 = atof(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'L') {
							if (model == "Cylinder") {
								length = atof(&argv[i][3]);
								break;
							}
							if (model == "Sphere") {
								radius = atof(&argv[i][3]);
							}
							cout << "\nFlag -ML is only valid for Cylinder and Sphere Models";
							break;
						}
						cout << "\nUnrecognized flag: -M" << argv[i][2];
						break;

					case 'L':
						if (argv[i][2] == 'X') {
							lambdaEx = atof(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'P') {
							polarized = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'A') {
							thetaPol = atof(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'M') {
							if (argv[i][3] == 'U') {
								lambdaEmMax = atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'L') {
								lambdaEmMin = atof(&argv[i][4]);
								break;
							}
							cout << "\nUnrecognized flag: -WM" << argv[i][3];
							break;
						}
						cout << "\nUnrecognized flag: -W" << argv[i][2];
						break;

					case 'C':
						if (argv[i][2] == 'U') {
							zGapMax = atof(&argv[i][3]);
							FLIC_points = floor( (zGapMax-zGapMin)/zGapSpacing ) + 1;
							break;
						}
						if (argv[i][2] == 'L') {
							zGapMin = atof(&argv[i][3]);
							FLIC_points = floor( (zGapMax-zGapMin)/zGapSpacing ) + 1;
							break;
						}
						if (argv[i][2] == 'S') {
							zGapSpacing = atof(&argv[i][3]);
							FLIC_points = floor( (zGapMax-zGapMin)/zGapSpacing ) + 1;
							break;
						}
						if (argv[i][2] == 'D') {
							zGap_derivStep = atof(&argv[i][3]);
							break;
						}
						cout << "\nUnrecognized flag: -D" << argv[i][2];
						break;


					case 'I':  //
						if (argv[i][2] == 'A') {
							num_angles = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'S') {
							num_angle_stacks = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'N') {
							seq_start_num = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'R') {
							reference = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'E') {
							image_file_ext = &argv[i][3];
							break;
						}
						cout << "\nUnrecognized flag: -I" << argv[i][2];
						break;


					case 'F':  //Fit parameters Local fitting parameters
						if (argv[i][2] == 'R') {
							startRow = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'C') {
							startCol = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'X') {
							constraint = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'W') {
							usecurves = atoi(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'D') {
							maxDisplacement = atof(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'M') {
							MS_step = atof(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'A') {
							if (argv[i][3] == 'U') {
								A_max = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'L') {
								A_min = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'G') {
								A_guess = MaxRGB*atof(&argv[i][4]);
								break;
							}
							cout << "\nUnrecognized flag: -FA" << argv[i][3];
							break;
						}
						if (argv[i][2] == 'B') {
							if (argv[i][3] == 'U') {
								B_max = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'L') {
								B_min = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'G') {
								B_guess = MaxRGB*atof(&argv[i][4]);
								break;
							}
							cout << "\nUnrecognized flag: -FB" << argv[i][3];
							break;
						}
						if (argv[i][2] == 'L') {
							if (argv[i][3] == 'U') {
								L_max = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'L') {
								L_min = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'G') {
								L_guess = MaxRGB*atof(&argv[i][4]);
								break;
							}
							cout << "\nUnrecognized flag: -FL" << argv[i][3];
							break;
						}
						if (argv[i][2] == 'H') {
							if (argv[i][3] == 'U') {
								H_max = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'L') {
								H_min = MaxRGB*atof(&argv[i][4]);
								break;
							}
							if (argv[i][3] == 'G') {
								H_guess = MaxRGB*atof(&argv[i][4]);
								break;
							}
							cout << "\nUnrecognized flag: -FH" << argv[i][3];
							break;
						}

						cout << "\nUnrecognized flag: -L" << argv[i][2];
						break;


					case 'S':  //Surface algorithm parameters

						if (argv[i][2] == 'E') {
							surface = atoi(&argv[i][2]);
						}
						if (argv[i][2] == 'S') {
							smoothness = atof(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'I') {
							interp = argv[i][3];
							break;
						}
						if (argv[i][2] == 'R') {
							regularizer = argv[i][3];
							break;
						}
						if (argv[i][2] == 'X') {
							xinc = atof(&argv[i][3]);
							break;
						}
						if (argv[i][2] == 'Y') {
							yinc = atof(&argv[i][3]);
							break;
						}
						cout << "\nUnrecognized flag: -L" << argv[i][2];
						break;

					case 'P':
						nthreads = atoi(&argv[i][2]);
						break;

					case 'R':
						report = atoi(&argv[i][2]);
						break;
				}

			}
		}
	}

	if (mode != 33) {
		//output parameters to file
		//Write data to file
		mkdir("output", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH); //Make the directory if not already created

		file_path = "output/" + image_name + "_Summary.txt";
		sfile.open ( file_path.c_str() );

		//Line 1
		sfile << "PARAMETERS: " << "\n2\n";
		sfile << "\tImage Name: " << image_name << "\n";
		sfile << "\tModel: " << model << "\n";
		sfile << "\tFluorophore: " << Dye << "\n";
		sfile << "\tFluorophore Dipole Angle: " << thetaDye*RTD << "\n";
		sfile << "\tRefractive Index - Silicon Oxide: " << n1 << "\n";
		sfile << "\tRefractive Index - Silicon: " << n0 << "\n";
		sfile << "\t Thickness - Silicon Oxide (nm): " << d1 << "\n";
		sfile << "\t Refractive Index - Buffer/Cytoplasm: " << n2 << "\n";
		if (model == "Cylinder") sfile << "15\tCylinder vertical length: " << length << "\n";
		else sfile << "\tCylinder vertical length: " << "NA" << "\n";
		if (model == "Sphere") sfile << "16\tSphere Radius: " << radius << "\n";
		else sfile << "\tSphere Radius: " << "NA" << "\n";
		sfile << "\tExcitation Wavelength: " << lambdaEx << "\n";
		sfile << "\tEmission Wavelength Min: " << lambdaEmMin << "\n";
		sfile << "\tEmission Wavelength Max: " << lambdaEmMax << "\n";
		sfile << "\tObjective NA: " << Obj_NA << "\n";
		sfile << "\tFLIC Curves - Min Z: " << zGapMin << "\n";
		sfile << "\tFLIC Curves - Max Z: " << zGapMax << "\n";
		sfile << "\tFLIC Curves - Z spacing: " << zGapSpacing << "\n";
		sfile << "\tFLIC Curves - Points: " << FLIC_points << "\n";
		sfile << "\tFLIC Curves - Derivative Step: " << zGap_derivStep << "\n";
		sfile << "\tNumber of Images/Angles: " << num_angles << "\n";
		sfile << "\tNumber of Angle Stacks per Set: " << num_angle_stacks << "\n";
		sfile << "\tImage Angles: ";
		for (i = 0; i < num_angles; i++) sfile << thetaLaser[i]*RTD << ", ";
		sfile << "\n\tIntensities corrected: " << reference << "\n";
		sfile << "\tIntensitiy correction factors: ";
		if (reference != 0 && ref_source == "Array")
			for (i = 0; i < num_angles; i++) sfile << ref_I[i] << ", ";
		else cout << "NA";
		sfile << "\n\tImage file ext: " << image_file_ext << "\n";
		sfile << "\tSolver: " << solver << "\n";
		sfile << "\tParameters: " << fit << "\n";
		sfile << "\tConstraint: " << constraint << "\n";
		sfile << "\tA Guess: " << A_guess << "\n";
		sfile << "\tB Guess: " << B_guess << "\n";
		sfile << "\tH Guess: " << H_guess << "\n";
		sfile << "\tZ-Height - Lower Bounds: " << H_min << "\n";
		sfile << "\tZ-Height - Upper Bounds: " << H_max << "\n";
		sfile << "\tA - Lower Bounds: " << A_min << "\n";
		sfile << "\tA - Upper Bounds: " << A_max << "\n";
		sfile << "\tB - Lower Bounds: " << B_min << "\n";
		sfile << "\tB - Upper Bounds: " << B_max << "\n";
		sfile <<  "\tMultiStart Step Size: " << MS_step << "\n";
		sfile << "\tMaximum displacement in constrained local fitting: "  << maxDisplacement << "\n";
		sfile << "\tLocal fitting starting row: " << startRow << "\n";
		sfile << "\tLocal fitting starting column: "  << startCol << "\n";
		sfile << "\tSurface: " << surface << "\n";
		sfile << "\tSurface Smoothness: " << smoothness << "\n";
		sfile << "\tSurface Interpolation Method: " << interp << "\n";
		sfile << "\tSurface Regularizer: " << regularizer << "\n";
		sfile << "\tSurface x-increment: " << xinc << "\n";
		sfile << "\tSurface y-increment: " << yinc << "\n";
		sfile << "\n55\tCONSTANTS: " << "\n56\n";
		sfile << "\tPI: " << PI << " DTR: " << DTR << " RTD: " << RTD <<  "\n";
	}

    cout << "Finished Loading Parameters\n";
    if (mode == 0) {
    	return 0;
    }

    //******************************Check the selected parameters for compatibility***************************************

    //Make sure the number of threads does not exceed the maximum available on the system
	if (nthreads < 1) nthreads = 1;
	if ( nthreads > omp_get_max_threads() ); nthreads = omp_get_max_threads();;
	omp_set_num_threads(nthreads);
	cout <<  "Using " << omp_get_max_threads() << " threads in parallel algorithms!!!" << "\n";

	if (solver != 'l') {
		cout << "Error:  Only 'l' is currently a valid choice for the fitting algorithm.  Changing the solver to 'l'\n";
		solver = 'l';
	}
	if (fit != "HAB" && fit != "HABL" && fit != "HoAB" && fit != "HABC" && fit != "HABCL" && fit != "HABCQ") {
		cout << "The fit type must be 'HAB', 'HoAB', 'HABL', 'HABC', 'HABCL', or 'HABCQ' - Changing model to 'HAB'\n";
		fit = "HAB";
	}
	if (fit == "HABL" && model == "Point") {
		cout << "Only Sphere and Cylinder models currently support 4 parameter fitting - changing fit to HAB\n";
		fit = "HAB";
	}
	if (fit == "HoAB" && usecurves != 0) {
		cout << "HoAB currently only works with the FLIC curve approximation - Changing usecurves to 0\n";
		usecurves = 0;
	}
	if (fit == "HABC" && usecurves != 1) {
		cout << "HABC currently only works with the FLIC curve approximation - Changing usecurves to 1\n";
		usecurves = 1;
	}
	if (fit == "HABCL" && usecurves != 1) {
		cout << "HABCL currently only works with the FLIC curve approximation - Changing usecurves to 1\n";
		usecurves = 1;
	}
	if (fit == "HABCQ" && usecurves != 1) {
		cout << "HABCQ currently only works with the FLIC curve approximation - Changing usecurves to 1\n";
		usecurves = 1;
	}
	if (model == "Membrane"  && fit != "HAB") {
		cout << "The fit type for a Membrane model must be 'HAB'. Changing fit to 'HAB'\n";
		fit = "HAB";
	}
	if (model == "Membrane"  && usePem != 0) {
			cout << "The Membrane model does not currently incorporate a term for the probability of emission. Changing usePem to 0\n";
			usePem = 0;
		}

	//***********************************Construct the FLIC curves or read them from file**********************************

	//Calculate thetaObjMax
	thetaObjMax = asin(Obj_NA/Obj_RI);
	cout << "thetaObjMax: " << thetaObjMax*RTD << "\n";

    //Allocate memory for the FLIC curves,
    ZGAP = new double[FLIC_points];
	FLIC = new double[FLIC_points*num_angles];
	DERIV = new double[FLIC_points*num_angles];

	//Generate the FLIC curves if the flag, construct_FLIC_Curves,  = 1, otherwise read in FLIC curves from file
	if (mode == 11 || mode == 12 || mode == 13) {

		//Initialize the interpolator for the membrane dye spectra
		spectra_acc = gsl_interp_accel_alloc ();

		if (Dye == "DiO") {
			//spectra_acc = gsl_interp_accel_alloc ();
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, DiO_elements);
			gsl_spline_init (spectra_spline, DiO_Lam, DiO_Em, DiO_elements);
		}
		else if (Dye == "DiI") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, DiI_elements);
			gsl_spline_init (spectra_spline, DiI_Lam, DiI_Em, DiI_elements);
		}
		else if (Dye == "mCherry") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, mCherry_elements);
			gsl_spline_init (spectra_spline, mCherry_Lam, mCherry_Em, mCherry_elements);
		}
		else if (Dye == "eGFP") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, eGFP_elements);
			gsl_spline_init (spectra_spline, eGFP_Lam, eGFP_Em, eGFP_elements);
		}
		else if (Dye == "Alexa488") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, Alexa488_elements);
			gsl_spline_init (spectra_spline, Alexa488_Lam, Alexa488_Em, Alexa488_elements);
		}
		else if (Dye == "Alexa568") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, Alexa568_elements);
			gsl_spline_init (spectra_spline, Alexa568_Lam, Alexa568_Em, Alexa568_elements);
		}
		else if (Dye == "Alexa594") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, Alexa594_elements);
			gsl_spline_init (spectra_spline, Alexa594_Lam, Alexa594_Em, Alexa594_elements);
		}
		else if (Dye == "Cy3") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, Cy3_elements);
			gsl_spline_init (spectra_spline, Cy3_Lam, Cy3_Em, Cy3_elements);
		}
		else if (Dye == "Cy5") {
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, Cy5_elements);
			gsl_spline_init (spectra_spline, Cy5_Lam, Cy5_Em, Cy5_elements);
		}

		else if (Dye == "Custom") {
			//Note:  This code still needs to be tested
			//Read in the csv file to a couple of vectors
			int spectra_elements = 0;
			vector<double> lam, em;
			ifstream inFile ("Spectra.csv");
			while (getline (inFile, line))
			{
			    spectra_elements++;
			    linestream.clear();
			    linestream.str(line);
			    getline (linestream, item, ',');
			    removeAllWhiteSpaces(item);
			    lam.push_back( StrToDouble(item) );
			    getline (linestream, item, ',');
			    removeAllWhiteSpaces(item);
			    em.push_back( StrToDouble(item) );
			}
			//Transfer the contents of the vectors to two c arrays
			double * spectra_Lam = new double [spectra_elements];
			double * spectra_Em = new double [spectra_elements];
			for (i = 0; i < spectra_elements; i++) {
				spectra_Lam[i] = lam[i];
				spectra_Em[i] = em[i];
			}
			//Create the splines
			spectra_spline = gsl_spline_alloc (gsl_interp_cspline, spectra_elements);
			gsl_spline_init (spectra_spline, spectra_Lam, spectra_Em, spectra_elements);

			//Delete the arrays/vectors holding the original spectra data
			lam.clear();
			em.clear();
			delete [] spectra_Lam;
			delete [] spectra_Em;

		}
		else {
			cout << "Error: Dye must have a value of 'DiO', 'DiI', mCherry, or Custom - Aborting Program";
			delete [] ZGAP;
			delete [] FLIC;
			delete [] DERIV;
			return 1;
		}

		cout << "fit: " << fit << "\n";
		//Generate the FLIC curves
		start = time(NULL);
		max = generateFLICCurves(ZGAP, FLIC, DERIV, num_angles);  //construct the curves

		cout << "\nTime to generate FLIC Curves : " << time(NULL) - start << "\n";
		cout << "\nFLIC curve normalization factor: " << max;
		sfile << "\n\nCurves:\n\n";
		sfile << "\tFLIC curve Normalization factor: " << max << "\n";

		//Write the FLIC curves to file
		mkdir("curves", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH); //Make the directory if not already created
		arrayWriter(ZGAP, FLIC_points, "curves/ZGAP.csv");
		arrayWriter(FLIC, FLIC_points*num_angles, "curves/FLIC.csv");
		arrayWriter(DERIV, FLIC_points*num_angles, "curves/DERIV.csv");

		cout << "\nFLIC_points: " << FLIC_points << "\n";

		if (mode == 11) {
			delete [] ZGAP;
			delete [] FLIC;
			delete [] DERIV;

			//Free the interpolator memory
			gsl_spline_free(spectra_spline);
			gsl_interp_accel_free(spectra_acc);

			return 0;  //Completed
		}

		if (usecurves == 1) {
			//Initialize the interpolators for the FLIC curves
			FLIC_acc = gsl_interp_accel_alloc ();
			DERIV_acc = gsl_interp_accel_alloc ();
			FLIC_spline = gsl_spline_alloc (gsl_interp_cspline, FLIC_points);
			DERIV_spline = gsl_spline_alloc (gsl_interp_cspline, FLIC_points);
			gsl_spline_init (FLIC_spline, ZGAP, FLIC, FLIC_points);
			gsl_spline_init (DERIV_spline, ZGAP, DERIV, FLIC_points);
		}
	}

	else if ( (mode == 23 || mode == 22) && usecurves == 1 ){		//otherwise read in FLIC curves from file
		if ( !readCSVtoArray(ZGAP, "curves/ZGAP.csv") ) {
			cout << "\nFLIC curves (ZGAP.csv) could not be opened - Aborting program\n";
			return 1;
		}
		if ( !readCSVtoArray(FLIC, "curves/FLIC.csv") ) {
			cout << "\nFLIC curves (FLIC.csv) could not be opened - Aborting program\n";
			delete [] ZGAP;
			return 1;
		}
		if ( !readCSVtoArray(DERIV, "curves/DERIV.csv") ) {
			cout << "\nFLIC curves (DERIV.csv) could not be opened - Aborting program\n";
			delete [] ZGAP;
			delete [] FLIC;
			return 1;
		}

		//Initialize the interpolators for the FLIC curves
		FLIC_acc = gsl_interp_accel_alloc ();
		DERIV_acc = gsl_interp_accel_alloc ();
		FLIC_spline = gsl_spline_alloc (gsl_interp_cspline, FLIC_points);
		DERIV_spline = gsl_spline_alloc (gsl_interp_cspline, FLIC_points);
		gsl_spline_init (FLIC_spline, ZGAP, FLIC, FLIC_points);
		gsl_spline_init (DERIV_spline, ZGAP, DERIV, FLIC_points);
	}



    //*****************************Open all the tiff images in the sequence and store****************************
	//*****************************their pixel values in row-major format in "images"****************************

	if (mode != 33) {
		if (data_source == "Image") {
			//Open the background images and record the average background for each of the main FLIC image
			vector<double> bg_I (num_angles,0);
			if (background == 1) {
				generate_image_seq_path(file_path, "images/", image_name + "B", image_file_ext, seq_start_num);
				getImageSize(file_path, num_rows, num_cols);
				Images_temp = new int[ num_rows*num_cols*num_angles*num_angle_stacks ];
				intensity = 0;

				for (j = 0; j < num_angle_stacks; j++) {
					for (i = 0; i < num_angles; i++) {
						index = j*num_angles + i;
						generate_image_seq_path(file_path, "images/", image_name + "B", image_file_ext, seq_start_num + index);
						if ( loadImage(&Images_temp[index*num_rows*num_cols], file_path, num_rows, num_cols) != 1) {
							cout << "\nAborting Program\n";
							delete [] Images_temp;
							delete [] ZGAP;
							delete [] FLIC;
							delete [] DERIV;
							gsl_spline_free(spectra_spline);
							gsl_interp_accel_free(spectra_acc);
							gsl_spline_free(FLIC_spline);
							gsl_interp_accel_free(FLIC_acc);
							gsl_spline_free(DERIV_spline);
							gsl_interp_accel_free(DERIV_acc);
							return 0;
						}
						//Record the average intensity in each of the background images
						intensity = 0;
						for (k = 0; k < num_rows*num_cols; k++) intensity = intensity + Images_temp[k + index*num_rows*num_cols];
						intensity = intensity/(num_rows*num_cols);
						bg_I[i] = bg_I[i] + intensity;
					}
				}

				for (i = 0; i < num_angles; i++)
					bg_I[i] = bg_I[i]/num_angle_stacks;

				delete [] Images_temp;
			}

			//If reference image
			double ref_mean = 0.0;
			int num_for_ref_mean = 0;
			if (reference == 1) {

				if (ref_source == "Image") {
					file_path = "reference/reference0000.tif";
					getImageSize(file_path, num_rows, num_cols);

					cout << "Reference Image Size: " << num_rows << " x " << num_cols << "\n";

					ref_averages = new double[num_angles*num_angle_stacks*num_rows*num_cols];
					nrefs = new int[num_angles*num_angle_stacks*num_rows*num_cols];
					ref_thresh = new int[num_rows*num_cols];
					ref_image = new int[num_rows*num_cols];

					//Initialize ref_averages and nrefs
					for (i = 0; i < num_angles*num_rows*num_cols; i++) {
						ref_averages[i] = 0.0;
						nrefs[i] = 0;
					}

					//Load the images
					for (i = 0; i < num_ref_sets; i++) {

						cout << "Loading image set: " << i << "\n";

						if (ref_threshold != 0) {
							//Get the file path for the threshold image
							if (i < 10) file_path = "reference/reference0" + IntToStr(i) + "T.tif";
							else file_path = "reference/reference" + IntToStr(i) + "T.tif";

							//Open the threshold image
							if (loadImage(ref_thresh, file_path, num_rows, num_cols) != 1) {
								cout << "\nAborting Program\n";
								delete [] ref_thresh;
								delete [] ref_averages;
								delete [] nrefs;
								delete [] ref_image;
								delete [] Images_temp;
								delete [] ZGAP;
								delete [] FLIC;
								delete [] DERIV;
								gsl_spline_free(spectra_spline);
								gsl_interp_accel_free(spectra_acc);
								gsl_spline_free(FLIC_spline);
								gsl_interp_accel_free(FLIC_acc);
								gsl_spline_free(DERIV_spline);
								gsl_interp_accel_free(DERIV_acc);
								return 0;
							}
						}

						//Loop through each image in the set and add to the running reference averages
						cout << "Loading reference images\n";
						for (j = 0; j < num_angles*num_angle_stacks; j++) {

							//Get the file path of the image to open
							if (i < 10) {
								if (j < 10) file_path = "reference/reference0" + IntToStr(i) + "0" + IntToStr(j) + ".tif";
								else file_path = "reference/reference0" + IntToStr(i) + IntToStr(j) + ".tif";
							}
							else {
								if (j < 10) file_path = "reference/reference" + IntToStr(i) + "0" + IntToStr(j) + ".tif";
								else file_path = "reference/reference" + IntToStr(i) + IntToStr(j) + ".tif";
							}

							//Open the image
							if (loadImage(ref_image, file_path, num_rows, num_cols) != 1) {
								cout << "\nAborting Program\n";
								delete [] ref_thresh;
								delete [] ref_averages;
								delete [] nrefs;
								delete [] ref_image;
								delete [] Images_temp;
								delete [] ZGAP;
								delete [] FLIC;
								delete [] DERIV;
								gsl_spline_free(spectra_spline);
								gsl_interp_accel_free(spectra_acc);
								gsl_spline_free(FLIC_spline);
								gsl_interp_accel_free(FLIC_acc);
								gsl_spline_free(DERIV_spline);
								gsl_interp_accel_free(DERIV_acc);
								return 0;
							}

							//Add to the running reference averages
							for (k = 0; k < num_rows*num_cols; k++) {
								if (ref_threshold != 0) {
									if (ref_thresh[k] == ref_process_integer) {  //add it
										ref_averages[j*num_rows*num_cols + k] = ref_averages[j*num_rows*num_cols + k] + ref_image[k];
										ref_mean = ref_mean + ref_image[k];
										nrefs[j*num_rows*num_cols + k]++;
										num_for_ref_mean++;
									}
								}
								else {
									ref_averages[j*num_rows*num_cols + k] = ref_averages[j*num_rows*num_cols + k] + ref_image[k];
									ref_mean = ref_mean + ref_image[k];
									nrefs[j*num_rows*num_cols + k]++;
									num_for_ref_mean++;
								}
							}
						}
					}

					//Compute the Averages
					ref_mean = ref_mean/num_for_ref_mean;
					for (i = 0; i < num_angles*num_angle_stacks*num_rows*num_cols; i++) {
						if (nrefs[i] != 0)
							ref_averages[i] = ref_averages[i]/nrefs[i];
						else ref_averages[i] = ref_mean;
					}

					//Save the images
					cout << "Saving reference images\n";
					for (i = 0; i < num_angles*num_angle_stacks; i++) {

						//Create the file path
						if (i < 10) file_path = "reference/referenceAve0" + IntToStr(i) + ".pgm";
						else file_path = "reference/referenceAve" + IntToStr(i) + ".pgm";

						//Create the image
						writeImagePGM(&ref_averages[i*num_rows*num_cols], num_cols, num_rows, file_path);
					}

					delete [] ref_thresh;
					delete [] nrefs;
					delete [] ref_image;
				}
			}


			//Open the main FLIC image files
			generate_image_seq_path(file_path, "images/", image_name, image_file_ext, seq_start_num);
			getImageSize(file_path, num_rows, num_cols);

			Images = new double[ num_rows*num_cols*num_angles ];
			Images_temp = new int[ num_rows*num_cols*num_angles*num_angle_stacks ];

			for (i = 0; i <  num_rows*num_cols*num_angles; i++) Images[i] = 0;

			cout << "Loading FLIC data images\n";
			for (j = 0; j < num_angle_stacks; j++) {
				for (i = 0; i < num_angles; i++) {
					index = j*num_angles + i;
					generate_image_seq_path(file_path, "images/", image_name, image_file_ext, seq_start_num+index);
					if (loadImage(&Images_temp[index*num_rows*num_cols], file_path, num_rows, num_cols) != 1) {
						cout << "\nAborting Program\n";
						delete [] Images_temp;
						delete [] Images;
						delete [] ZGAP;
						delete [] FLIC;
						delete [] DERIV;
						gsl_spline_free(spectra_spline);
						gsl_interp_accel_free(spectra_acc);
						gsl_spline_free(FLIC_spline);
						gsl_interp_accel_free(FLIC_acc);
						gsl_spline_free(DERIV_spline);
						gsl_interp_accel_free(DERIV_acc);
						if (reference == 1 && ref_source == "Image")
							delete [] ref_averages;
						return 0;
					}
				}
			}

			//Load the average of the images in each image set into images
			for (i = 0; i < num_angles; i++) {
				for (k = 0; k < num_rows*num_cols; k++) {
					Images[k + i*num_rows*num_cols] = 0.0;
				}
			}
			cout << "refCamera: " << refCamera << " imageCamera: " << imageCamera << " ref_mean: " << ref_mean << "\n";
			for (j = 0; j < num_angle_stacks; j++) {
				for (i = 0; i < num_angles; i++) {
					for (k = 0; k < num_rows*num_cols; k++) {
						//Load the intensity an normalize the intensity according to a reference if necessary
						if (reference == 1) {
							if (ref_source == "Image") {
								Images[k + i*num_rows*num_cols] = Images[k + i*num_rows*num_cols] +
										(Images_temp[k + i*num_rows*num_cols + j*num_rows*num_cols*num_angles] - imageCamera) /
										( (ref_averages[k + i*num_rows*num_cols + j*num_rows*num_cols*num_angles] - refCamera) / (ref_mean - refCamera) );
							}
							else if (ref_source == "Array") {
								Images[k + i*num_rows*num_cols] = Images[k + i*num_rows*num_cols] +
										(Images_temp[k + i*num_rows*num_cols + j*num_rows*num_cols*num_angles] - imageCamera) / (ref_I[i] - refCamera);
							}

						}
						else {
							Images[k + i*num_rows*num_cols] = Images[k + i*num_rows*num_cols]
								  + Images_temp[k + i*num_rows*num_cols + j*num_rows*num_cols*num_angles];
						}
					}
				}
			}
			//j*num_angles + i
			for (i = 0; i < num_angles; i++) {
				for (k = 0; k < num_rows*num_cols; k++) {
					Images[k + i*num_rows*num_cols] = Images[k + i*num_rows*num_cols]/num_angle_stacks;
				}
			}

			//Substract a background from the FLIC images
			if (background == 1) {
				for (i = 0; i < num_angles; i++) {
					for (j = 0; j < num_rows*num_cols; j++) {
						Images[i*num_rows*num_cols + j] = Images[i*num_rows*num_cols + j] - bg_I[i];  //Reference laser intensities provided
					}
				}
			}

			//Save the normalized images
			mkdir("norm_images", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH); //Make the directory if not already created
			cout << "Saving normalized FLIC data images\n";
			for (i = 0; i < num_angles; i++) {

				//Create the file path
				generate_image_seq_path(file_path, "norm_images/", image_name, ".pgm", i);

				//Create the image
				writeImagePGM(&Images[i*num_rows*num_cols], num_cols, num_rows, file_path);
			}

			//Delete some arrays that are no longer needed
			delete [] Images_temp;
			if (reference == 1 && ref_source == "Image")
				delete [] ref_averages;

			//Open the Threshold image
			Thresh = new int[ num_rows*num_cols ];
			cout << "About to open thresh\n";
			if (threshold == 1) {
				file_path = "images/" + image_name + "T" + image_file_ext;  //".tif";
				getImageSize(file_path, thresh_nrows, thresh_ncols);

				if ( thresh_nrows != num_rows || thresh_ncols != num_cols) {
					cout <<  "\nThreshold image must be same size as main fluorescent images - Aborting!\n";
					delete [] Images;
					delete [] Thresh;
					delete [] ZGAP;
					delete [] FLIC;
					delete [] DERIV;
					gsl_spline_free(spectra_spline);
					gsl_interp_accel_free(spectra_acc);
					gsl_spline_free(FLIC_spline);
					gsl_interp_accel_free(FLIC_acc);
					gsl_spline_free(DERIV_spline);
					gsl_interp_accel_free(DERIV_acc);
					return 0;
				}

				if (loadImage(Thresh, file_path, num_rows, num_cols) != 1) {
					cout << "\nAborting Program\n";
					delete [] Images;
					delete [] Thresh;
					delete [] ZGAP;
					delete [] FLIC;
					delete [] DERIV;
					gsl_spline_free(spectra_spline);
					gsl_interp_accel_free(spectra_acc);
					gsl_spline_free(FLIC_spline);
					gsl_interp_accel_free(FLIC_acc);
					gsl_spline_free(DERIV_spline);
					gsl_interp_accel_free(DERIV_acc);
					return 0;
				}

				//Make threshold image binary
				for (k = 0; k < num_rows*num_cols; k++) {
					if (Thresh[k] == process_integer) Thresh[k] = 1;
					else Thresh[k] = 0;
				}
			}
			else {
				for (i = 0; i < num_rows*num_cols; i++) {
					Thresh[i] = 1;  //Pixels will be processed
				}
			}
		}
		else if (data_source == "Array") {
			num_rows = 1;
			num_cols = 1;
			startRow = 0;
			startCol = 0;
			Images = new double[ num_angles ];
			Thresh = new int[ num_rows*num_cols ];

			//Load the data
			for (i = 0; i < num_angles; i++)
				Images[i] = 0.0;

			for (j= 0; j < num_angle_stacks; j++) {
				for (i = 0; i < num_angles; i++) {
					Images[i] = Images[i] + data_array[j*num_angles+i]/num_angle_stacks;
				}
			}

			//Correct for intensity variation
			if (reference == 1) {
				for (i = 0; i < num_angles; i++) {
					Images[i] = (Images[i]-imageCamera)/(ref_I[i]-refCamera);  //Reference laser intensities provided
				}
			}

			//Print Data
			cout << "\nDATA:\n";
			for (i = 0; i < num_angles; i++) cout << thetaLaser[i]*RTD << ": " << Images[i] << "\n";

			//Process it
			Thresh[0] = 1;
		}

		else {
			cout << "\nAborting Program - Primary FLIC data source must be 'Image' or 'Array'\n";
			delete [] Images_temp;
			delete [] ZGAP;
			delete [] FLIC;
			delete [] DERIV;
			gsl_spline_free(spectra_spline);
			gsl_interp_accel_free(spectra_acc);
			gsl_spline_free(FLIC_spline);
			gsl_interp_accel_free(FLIC_acc);
			gsl_spline_free(DERIV_spline);
			gsl_interp_accel_free(DERIV_acc);
			return 0;
		}

		//**********************Calculate the best-estimate fit membrane height at each pixel*************************
		cout << "fitting time!\n";
		//Allocate the
		//matrix H for storing the best-estimate of the membrane height at each image pixel
		H = new double[ num_rows*num_cols ];
		R = new double[ num_rows*num_cols ];
		A = new double[ num_rows*num_cols ];
		B = new double[ num_rows*num_cols ];
		L = new double[ num_rows*num_cols ];
		F = new int[ num_rows*num_cols ];
		XF = new double[ num_rows*num_cols ];
		YF = new double[ num_rows*num_cols ];
		HF = new double[ num_rows*num_cols ];
		AF = new double[ num_rows*num_cols ];
		BF = new double[ num_rows*num_cols ];
		LF = new double[ num_rows*num_cols ];
		RF = new double[ num_rows*num_cols ];


		//Fill in F.  F[pixel] = 0 indicates that the pixel should be processed.  A value of 1
		//indicates the pixel height has already been computed successfully.  A value of 2 indicates that
		//the pixel will not be processed (or was processed unsuccessfully)
		unprocessed = 0;
		for (i = 0; i < num_rows*num_cols; i++) {
			if (Thresh[i] == 0) F[i] = 2;
			else {
				F[i] = 0;
				unprocessed = 1;
			}
		}

		//Initialize H, A, B , R
		for (i = 0; i < num_rows*num_cols; i++) {
			H[i] = 0;
			A[i] = -1.0;
			B[i] = -1.0;
			R[i] = -1.0;
		}

		start = time(NULL);
		cout << "\nCalling local fitter...\n";

		//Unconstrained fitting
		if (constraint == 0) {
			flag = localFLICfitter (Images, num_rows, num_cols, num_angles, ZGAP, FLIC, DERIV, H, A, B, L, R, F, fit);
		}
		else {  //Constrained fitting algorithm - For Membrane only
			//Check to make sure startRow and startCol are within the bounds of the image
			if (startCol >= num_cols || startCol < 0) {
				startCol = 0;
				cout << "\nWarning the specified starting column position exceeds the image dimensions";
			}
			if (startRow >= num_cols || startRow < 0) {
				startRow = 0;
				cout << "\nWarning the specified starting row position exceeds the image dimensions";
			}
			index = getIndex(startRow, startCol, 0, num_rows, num_cols);
			if (F[index] != 0) {
				cout << "\nWarning the start column and start pixel for the unconstrained fitting algorithm is not viable - Selecting an alternative starting pixel";
				for (i = 0; i < num_rows*num_cols; i++) {
					if (F[i] == 0) {
						index = i;
						break;
					}
				}
			}
			while (unprocessed != 0) {
				flag = localFLICfitterConstrained (Images, index, num_rows, num_cols, num_angles, ZGAP, FLIC, DERIV, H, A, B, L, R, F, constraint, maxDisplacement, fit);

				//Make sure all appropriate pixels have been processed.
				unprocessed = 0;
				for (i = 0; i < num_rows*num_cols; i++) {
					if (F[i] == 0) {
						unprocessed = 1;
						index = i;
						break;
					}
				}
			}
		}

		cout << "\nTime for local fitting: " << time(NULL) - start;
		cout << "\nFlag: " << flag;

		if (flag != 1) {
			cout << "\nLocal fitting failed - aborting!\n";
			delete [] Images;
			delete [] Thresh;
			delete [] ZGAP;
			delete [] FLIC;
			delete [] DERIV;
			delete [] H;
			delete [] A;
			delete [] B;
			delete [] L;
			delete [] R;
			delete [] F;
			delete [] XF;
			delete [] YF;
			delete [] HF;
			delete [] RF;
			delete [] AF;
			delete [] LF;

			//Free Intel MKL memory
		    MKL_FreeBuffers();

		    //Free the interpolator memory
			gsl_spline_free(spectra_spline);
			gsl_interp_accel_free(spectra_acc);
			gsl_spline_free(FLIC_spline);
			gsl_interp_accel_free(FLIC_acc);
			gsl_spline_free(DERIV_spline);
			gsl_interp_accel_free(DERIV_acc);

			sfile.close();

			return 0;
		}

		Ao = 0.0;
		Bo = 0.0;
		Ho = 0.0;
		Lo = 0.0;
		Ro = 0.0;
		nfitPix = 0;  //nFitPix is the number of successfully fit pixels
		cout << "r: " << num_rows <<  " c: " << num_cols << " F: " << F[0] << "\n";
		for (i = 0; i < num_rows*num_cols; i++) {
			if (F[i] == 1) {
				if ( !isnan(H[i]) && !isinf(H[i]) && H[i] > H_min && H[i] < H_max) {

					XF[nfitPix] = getCol(i, num_cols);
					YF[nfitPix] = getRow(i, num_cols);
					HF[nfitPix] = H[i];
					RF[nfitPix] = R[i];
					AF[nfitPix] = A[i];
					BF[nfitPix] = B[i];
					Ao = Ao+ A[i];
					Bo = Bo + B[i];
					Ro = Ro + R[i];
					Ho = Ho + H[i];
					if (fit == "HABL" || fit == "HABC" || fit == "HABCL" || fit == "HABCQ") {
						LF[nfitPix] = L[i];
						Lo = Lo + L[i];
					}
					nfitPix++;
				}
			}
		}

		Ao = Ao/nfitPix;
		Bo = Bo/nfitPix;
		Ro = Ro/nfitPix;
		Ho = Ho/nfitPix;
		if (fit == "HABL") Lo = Lo/nfitPix;

		cout << "\nAo: " << Ao << " Bo: " << Bo;

		//Write the best fit heights to file
		file_path = "output/" + image_name + "_H.csv";
		arrayWriter(H, num_rows*num_cols, file_path);

		//Write the best fit heights to file
		file_path = "output/" + image_name + "_HF.csv";
		arrayWriter(HF, nfitPix, file_path);

		//Write the best fit heights to file
		file_path = "output/" + image_name + "_XF.csv";
		arrayWriter(XF, nfitPix, file_path);

		//Write the best fit heights to file
		file_path = "output/" + image_name + "_YF.csv";
		arrayWriter(YF, nfitPix, file_path);

		file_path = "output/" + image_name + "_RF.csv";
		arrayWriter(RF, nfitPix, file_path);

		file_path = "output/" + image_name + "_AF.csv";
		arrayWriter(AF, nfitPix, file_path);

		file_path = "output/" + image_name + "_BF.csv";
		arrayWriter(BF, nfitPix, file_path);

		file_path = "output/" + image_name + "_R.csv";
		arrayWriter(R, num_rows*num_cols, file_path);

		file_path = "output/" + image_name + "_A.csv";
		arrayWriter(A, num_rows*num_cols, file_path);

		file_path = "output/" + image_name + "_B.csv";
		arrayWriter(B, num_rows*num_cols, file_path);

		if (fit == "HABL" || fit == "HABC" || fit == "HABCL" || fit == "HABCQ") {
			cout << "\nprinting L of HABL or HABC data\n";
			file_path = "output/" + image_name + "_LF.csv";
			arrayWriter(LF, nfitPix, file_path);
		}

		file_path = "output/" + image_name + "_F.csv";
		arrayWriter(F, nfitPix, file_path);

		H_multiplier = MaxRGB/H[cblas_idamax(num_rows*num_cols, H, 1)];
		file_path = "output/" + image_name + "_H.tif";
		writeImage(H, H_multiplier, num_rows, num_cols, file_path);

		sfile << "\n\nSUMMARY:\n\n";
		sfile << "\tHo: " << Ho << "\n";
		sfile << "\tAo: " << Ao << "\n";
		sfile << "\tBo: " << Bo << "\n";
		sfile << "\tRo: " << Ro << "\n";
		if (fit == "HABL") sfile << "\tLo: " << Lo << "\n";
		else sfile << "\tLo: " << "NA" << "\n";
		sfile << "\tH Multipler: " << H_multiplier << "\n";

		cout << "\nHmin: " << HF[ cblas_idamin(nfitPix, HF, 1) ];

		cout << "\nrows: " << num_rows << " cols: " << num_cols << " number of fitted Pixels: " << nfitPix << "\n";
		sfile << "\tImage rows, cols: " << num_rows << "," << num_cols << "\n";
		sfile << "\tNumber of fitted Pixels: " << nfitPix << "\n";



		//**********************************************Create a Gradient Image**********************************


		//Calculate the gradient for each of the fit pixels
		int xSuccess, ySuccess;
		G = new double[ num_rows*num_cols ];
		GF = new double[ num_rows*num_cols ];

		for (i = 0; i < num_rows*num_cols; i++) {
			G[i] = 0;
		}

		for (i = 0; i < nfitPix; i++) {
			xSuccess = 0;
			ySuccess = 0;

			if (HF[i] > minForGrad && HF[i] < maxForGrad) {
				row = YF[i];
				col = XF[i];
				index = getIndex(row, col, 0, num_rows, num_cols);
				if (row > 0 && row < num_rows-1) {
					if (F[col + (row-1)*num_cols] == 1 && F[col + (row+1)*num_cols] == 1) {
						if (H[col + (row-1)*num_cols] > minForGrad && H[col + (row-1)*num_cols] < maxForGrad) {
							if (H[col + (row+1)*num_cols] > minForGrad && H[col + (row+1)*num_cols] < maxForGrad) {
								gradY = H[col + (row-1)*num_cols] - 2*HF[i] + H[col + (row+1)*num_cols];
								ySuccess = 1;
								//cout << "H[0]: " << H[getIndex(row-1, col, 0, num_rows, num_cols)] << " H[1]: " << HF[i] << "H[2]: " << H[getIndex(row+1, col, 0, num_rows, num_cols)] << " ";
							}
						}
					}
				}

				if (col > 0 && col < num_cols-1) {
					if (F[col-1 + row*num_cols] == 1 && F[col+1 + row*num_cols] == 1) {
						if (H[col-1 + row*num_cols] > minForGrad && H[col-1 + row*num_cols] < maxForGrad) {
							if (H[col+1 + row*num_cols] > minForGrad && H[col+1 + row*num_cols] < maxForGrad) {
								gradX = H[col-1 + row*num_cols] - 2*HF[i] + H[col+1 + row*num_cols];
								xSuccess = 1;
							}
						}
					}
				}
			}

			if (xSuccess == 1 && ySuccess == 1) {
				G[index] = sqrt(gradX*gradX + gradY*gradY);
			}
			/*else if (xSuccess == 1) {
				G[index] = abs(gradX);
			}
			else if (ySuccess == 1) {
				G[index] = abs(gradY);
			}*/

			GF[i] = G[index];
		}

		//Write out the gradient images and data files
		double G_multiplier = MaxRGB/G[cblas_idamax(num_rows*num_cols, G, 1)];
		file_path = "output/" + image_name + "_G.tif";
		writeImage(G, G_multiplier, num_rows, num_cols, file_path);
		cout << "G_multiplier: " << G_multiplier << "\n";

		sfile << "\tG Multipler: " << G_multiplier << "\n";

		file_path = "output/" + image_name + "_G.csv";
		arrayWriter(G, num_rows*num_cols, file_path);

		//Write the best fit heights to file
		file_path = "output/" + image_name + "_GF.csv";
		arrayWriter(GF, nfitPix, file_path);

		delete [] Images;
		delete [] Thresh;
		delete [] ZGAP;
		delete [] FLIC;
		delete [] DERIV;
		delete [] H;
		delete [] A;
		delete [] B;
		delete [] L;
		delete [] R;
		delete [] F;
		delete [] RF;
		delete [] AF;
		delete [] LF;
		delete [] G;
		delete [] GF;

	    //Free the interpolator memory
		gsl_spline_free(spectra_spline);
		gsl_interp_accel_free(spectra_acc);
		gsl_spline_free(FLIC_spline);
		gsl_interp_accel_free(FLIC_acc);
		gsl_spline_free(DERIV_spline);
		gsl_interp_accel_free(DERIV_acc);


		if (mode == 12 || mode == 22) {
			//finished routine
			delete [] XF;
			delete [] YF;
			delete [] HF;

			//Free Intel MKL memory
		    MKL_FreeBuffers();
			sfile.close();

			return 2;
		}

	}


	//**********************************************Smooth Using Surface*************************************

	if (mode == 33) {

		//Create storage
		HF = new double[ nfitPix ];
		XF = new double[ nfitPix ];
		YF = new double[ nfitPix ];

		if ( !readCSVtoArray(HF, "output/" + image_name + "_HF.csv") ) {
			cout << "\n" << image_name << "_HF.csv could not be opened - Aborting program\n";
			return 1;
		}
		if ( !readCSVtoArray(XF, "output/" + image_name + "_XF.csv") ) {
			cout << "\n" << image_name << "_XF.csv could not be opened - Aborting program\n";
			return 1;
		}
		if ( !readCSVtoArray(YF, "output/" + image_name + "_YF.csv") ) {
			cout << "\n" << image_name << "_YF.csv could not be opened - Aborting program\n";
			return 1;
		}

		xmax = S_ncols - 1;
		ymax = S_nrows - 1;

		//find xmax and ymax
		//xmax = XF[ cblas_idamax(nfitPix, XF, 1) ];
		//ymax = YF[ cblas_idamax(nfitPix, YF, 1) ];
	}
	else {
		xmax = num_cols - 1;
		ymax = num_rows - 1;
	}

	nx = floor(xmax/xinc) + 1;
	ny = floor(ymax/yinc) + 1;

	xnodes = new double[nx];
	ynodes = new double[ny];
	zgrid = new double[nx*ny];

	//Allocate xnodes and ynodes
	for(i = 0; i < nx; i++)
		xnodes[i] = i*xinc;

	for (i = 0; i < ny; i++)
		ynodes[i] = i*yinc;

	//Cull undesired fits
	XS = new double[ nfitPix ];
	YS = new double[ nfitPix ];
	HS = new double[ nfitPix ];
	int nsurfPix = 0;
	for (i = 0; i < nfitPix; i++) {
		if ( HF[i] > S_min && HF[i] < S_max) {
			XS[nsurfPix] = XF[i];
			YS[nsurfPix] = YF[i];
			HS[nsurfPix] = HF[i];
			nsurfPix++;
		}
	}
	cout << "\n" << "nsurfPix: " << nsurfPix << "\n";

	//Smooth the surface
	Surface (zgrid, XS, YS, HS, nsurfPix, xnodes, ynodes, nx, ny, smoothness, interp, regularizer);

	//Write the best fit heights to file
	file_path = "output/" + image_name + "_HS.csv";
	arrayWriter(zgrid, nx*ny, file_path);

	HS_multiplier = MaxRGB/zgrid[cblas_idamax(nx*ny, zgrid, 1)];
	file_path = "output/" + image_name + "_HS.tif";
	writeImage(zgrid, HS_multiplier, ny, nx, file_path);

	cout << "nrows Surface: " << ny<< " ncols Surface: " << nx << "\n";
	cout << "HS Multipler: " << HS_multiplier << "\n";

	if (mode != 33) {
		Ho = mean(zgrid, nx*ny);
		sfile << "\n\tHo (Surface): " << Ho << "\n";
		sfile << "\tHS Multipler: " << HS_multiplier << "\n";
		sfile << "\tSurface rows, cols: " << ny << "," << nx << "\n";
	}

	delete [] xnodes;
	delete [] ynodes;
	delete [] zgrid;
	delete [] HF;
	delete [] XF;
	delete [] YF;
	delete [] HS;
	delete [] XS;
	delete [] YS;

	//Free Intel MKL memory
	MKL_FreeBuffers();

	sfile.close();

	return 0;
}


//The probability function for excitation or emission derived by Lambacher
//and Fromherz, 1996 and 2002 for a five layer system
double P_Ex_Fromherz(double theta2, double lambda, double dg) {

	double P;

	//Calculate each theta
	double thetaM = asin(n2*sin(theta2)/nm);
	double thetaG = asin(nm*sin(thetaM)/ng);
	double theta1 = asin(ng*sin(thetaG)/n1);

	//Calculate complex theta0.  C++ does not have a standard asin function for complex
	//input.  Use Intel MKL instead.
	MKL_Complex16 mkl_n0, mkl_theta0;
	mkl_n0.real = n0.real();
	mkl_n0.imag = n0.imag();
	mkl_theta0.real = n1*sin(theta1);
	mkl_theta0.imag = 0.0;
	vzDiv(1, &mkl_theta0, &mkl_n0, &mkl_theta0);  	//Calculate n1*sin(theta1)/n0
	vzAsin(1, &mkl_theta0, &mkl_theta0);			//Calculate asin(n1*sin(theta1)/n0)
	complex<double> theta0(mkl_theta0.real, mkl_theta0.imag);  //Store the result in theta0

	//Calculate the phase shift
	double phi = (4*PI*nm/lambda)*dm*cos(thetaM);

	//Calculate the Fresnesl coefficient for the layer system (gap, Si02, Si)
	complex<double> p0 = n0*cos(theta0);
	double p1 = n1*cos(theta1);
	double pm = nm*cos(thetaM);
	double pg = ng*cos(thetaG);

	double t2mTE = 2*n2*cos(theta2)/(n2*cos(theta2) + nm*cos(thetaM));
	double rm2TE = (nm*cos(thetaM) - n2*cos(theta2))/(nm*cos(thetaM) + n2*cos(theta2));

	double kg = 2*PI*ng/lambda;
	double k1 = 2*PI*n1/lambda;

	double lg = kg*dg*cos(thetaG);
	double l1 = k1*d1*cos(theta1);

	complex<double> i(0,1);

	complex<double> m11TE = cos(lg)*cos(l1) - (p1/pg)*sin(lg)*sin(l1);
	complex<double> m12TE = -(i/p1)*cos(lg)*sin(l1) - (i/pg)*sin(lg)*cos(l1);
	complex<double> m21TE = -i*pg*sin(lg)*cos(l1) - i*p1*cos(lg)*sin(l1);
	complex<double> m22TE = -(pg/p1)*sin(lg)*sin(l1) + cos(lg)*cos(l1);

	complex<double> rTE = ((m11TE + m12TE*p0)*pm - (m21TE + m22TE*p0)) /
			((m11TE + m12TE*p0)*pm + (m21TE + m22TE*p0));

	complex<double> ifTE =   t2mTE*(1. + rTE)/(1. - rm2TE*rTE*exp(i*phi));
	double magSq_ifTE = abs(ifTE)*abs(ifTE);

	//If the light is linearly polarized orthogonal to the plane of incidence, everything needed is calculated. Return Pex;
	if (polarized == 1 && thetaPol == 90.0*DTR)
		return magSq_ifTE;

	//Calculate the Fresnesl coefficient (parallel components) for the layer system (Si02, Si)
	double t2mTM = 2*n2*cos(theta2)/(nm*cos(theta2) + n2*cos(thetaM));
	double rm2TM = (n2*cos(thetaM) - nm*cos(theta2))/(n2*cos(thetaM) + nm*cos(theta2));

	complex<double> q0 = cos(theta0)/n0;
	double q1 = cos(theta1)/n1;
	double qm = cos(thetaM)/nm;
	double qg = cos(thetaG)/ng;

	complex<double> m11TM = cos(lg)*cos(l1) - (q1/qg)*sin(lg)*sin(l1);
	complex<double> m12TM = (-i/q1)*cos(lg)*sin(l1) - (i/qg)*sin(lg)*cos(l1);
	complex<double> m21TM = -i*qg*sin(lg)*cos(l1) - i*q1*cos(lg)*sin(l1);
	complex<double> m22TM = -(qg/q1)*sin(lg)*sin(l1) + cos(lg)*cos(l1);

	complex<double> rTM = ((m11TM + m12TM*q0)*qm - (m21TM + m22TM*q0)) /
			((m11TM + m12TM*q0)*qm + (m21TM + m22TM*q0));

	complex<double> ifTM_p = t2mTM*(1. - rTM)/(1. - rm2TM*rTM*exp(i*phi));
	complex<double> ifTM_n = t2mTM*(1. + rTM)/(1. - rm2TM*rTM*exp(i*phi));

	double magSq_ifTM_p = abs(ifTM_p)*abs(ifTM_p);
	double magSq_ifTM_n = abs(ifTM_n)*abs(ifTM_n);

	//If the light is not polarized (or circularly polarized) and the dye dipoles have defined orientations
	if (polarized == 0) {
		P = sin(thetaDye)*sin(thetaDye)*magSq_ifTE + sin(thetaDye)*sin(thetaDye)*cos(theta2)*cos(theta2)*magSq_ifTM_p +
			2*cos(thetaDye)*cos(thetaDye)*sin(theta2)*sin(theta2)*magSq_ifTM_n;

		return P;
	}

	//If the light is linearly polarized and the dye dipoles have defined orientation
	P = sin(thetaDye)*sin(thetaDye)*sin(thetaPol)*sin(thetaPol)*magSq_ifTE +
		sin(thetaDye)*sin(thetaDye)*cos(theta2)*cos(theta2)*cos(thetaPol)*cos(thetaPol)*magSq_ifTM_p +
		2*cos(thetaDye)*cos(thetaDye)*sin(theta2)*sin(theta2)*cos(thetaPol)*cos(thetaPol)*magSq_ifTM_n;

	return P;

}

//The general probability function for excitation
double P_Ex(double theta2, double lambda, double d2) {

	double P;

	//Calculate each theta
	double theta1 = asin(n2*sin(theta2)/n1);	//Angle in silicon oxide

	//Calculate complex theta0.  C++ does not have a standard asin function for complex
	//input.  Use Intel MKL instead.
	MKL_Complex16 mkl_n0, mkl_theta0;
	mkl_n0.real = n0.real();
	mkl_n0.imag = n0.imag();
	mkl_theta0.real = n1*sin(theta1);
	mkl_theta0.imag = 0.0;
	vzDiv(1, &mkl_theta0, &mkl_n0, &mkl_theta0);  	//Calculate n1*sin(theta1)/n0
	vzAsin(1, &mkl_theta0, &mkl_theta0);			//Calculate asin(n1*sin(theta1)/n0)
	complex<double> theta0(mkl_theta0.real, mkl_theta0.imag);  //Store the result in theta0

	//Calculate the phase shift
	double phi = (4*PI*n2/lambda)*d2*cos(theta2);

	//Calculate the Fresnesl coefficient (perpendicular components) for the layer system (Si02, Si)
	complex<double> i(0,1);
	double k1 = 2*PI*n1/lambda;
	double l1 = k1*d1*cos(theta1);
	complex<double> p0 = n0*cos(theta0);
	double p1 = n1*cos(theta1);
	double p2 = n2*cos(theta2);
	complex<double> m11TE = cos(l1);
	complex<double> m12TE = -(i/p1)*sin(l1);
	complex<double> m21TE = -i*p1*sin(l1);
	complex<double> m22TE = cos(l1);

	//cout << "theta2: " << RTD*theta2 << " theta1: " << RTD*theta1 << " theta0: " << RTD*mkl_theta0.real << " phi: " << phi << " m11TE: " << m11TE <<  " m12TE: " << m12TE <<  " m21TE: " << m21TE <<  " m22TE: " << m22TE << "\n";

	complex<double> rTE = ((m11TE + m12TE*p0)*p2 - (m21TE + m22TE*p0)) / ((m11TE + m12TE*p0)*p2 + (m21TE + m22TE*p0));

	double magSq_ifTE = abs(1. + rTE*exp(i*phi))*abs(1. + rTE*exp(i*phi));

	//cout << "magSq_ifTE: " << magSq_ifTE << " polarized: " << polarized << " thetaPol: " << thetaPol << "\n";

	//If the light is linearly polarized orthogonal (parallel components) to the plane of incidence, everything needed is calculated
	//Return Pex;
	if (polarized == 1 && thetaPol == 90.0*DTR) {
		//cout << "here!";
		return magSq_ifTE;
	}

	//Calculate the Fresnesl coefficient for the layer system (Si02, Si)
	complex<double> q0 = cos(theta0)/n0;
	double q1 = cos(theta1)/n1;
	double q2 = cos(theta2)/n2;

	complex<double> m11TM = cos(l1);
	complex<double> m12TM = -(i/q1)*sin(l1);
	complex<double> m21TM = -i*q1*sin(l1);
	complex<double> m22TM = cos(l1);

	complex<double> rTM = ((m11TM + m12TM*q0)*q2 - (m21TM + m22TM*q0)) /
			((m11TM + m12TM*q0)*q2 + (m21TM + m22TM*q0));


	double magSq_ifTM_p = abs(1. - rTM*exp(i*phi))*abs(1. - rTM*exp(i*phi));
	double magSq_ifTM_n = abs(1. + rTM*exp(i*phi))*abs(1. + rTM*exp(i*phi));



	//If the light is not polarized (or circularly polarized) and the dye dipoles have defined orientations
	if (polarized == 0 && orientation == 1) {
		P = sin(thetaDye)*sin(thetaDye)*magSq_ifTE + sin(thetaDye)*sin(thetaDye)*cos(theta2)*cos(theta2)*magSq_ifTM_p +
			2*cos(thetaDye)*cos(thetaDye)*sin(theta2)*sin(theta2)*magSq_ifTM_n;

		return P;
	}

	//If the light is linearly polarized and the dye dipoles have defined orientation
	if (polarized == 1 && orientation == 1) {
		P = sin(thetaDye)*sin(thetaDye)*sin(thetaPol)*sin(thetaPol)*magSq_ifTE +
			sin(thetaDye)*sin(thetaDye)*cos(theta2)*cos(theta2)*cos(thetaPol)*cos(thetaPol)*magSq_ifTM_p +
			2*cos(thetaDye)*cos(thetaDye)*sin(theta2)*sin(theta2)*cos(thetaPol)*cos(thetaPol)*magSq_ifTM_n;

		return P;
	}

	//If the light is not polarized (or circularly polarized) and the dye dipoles are randomly distributed
	if (polarized == 0 && orientation == 0) {
		P = magSq_ifTE + cos(theta2)*cos(theta2)*magSq_ifTM_p +	2*sin(theta2)*sin(theta2)*magSq_ifTM_n;

		return P;
	}

	//If the light is linearly polarized and the dye dipoles are randomly oriented
	P = sin(thetaPol)*sin(thetaPol)*magSq_ifTE + cos(theta2)*cos(theta2)*cos(thetaPol)*cos(thetaPol)*magSq_ifTM_p +
		2*sin(theta2)*sin(theta2)*cos(thetaPol)*cos(thetaPol)*magSq_ifTM_n;

	return P;

}

double U_Em(double theta2, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double lambda = dbl_point[0];
	double d2 = dbl_point[1];
	double U;

	//Calculate each theta
	double theta1 = asin(n2*sin(theta2)/n1);	//Angle in silicon oxide

	//Calculate complex theta0.  C++ does not have a standard asin function for complex
	//input.  Use Intel MKL instead.
	MKL_Complex16 mkl_n0, mkl_theta0;
	mkl_n0.real = n0.real();
	mkl_n0.imag = n0.imag();
	mkl_theta0.real = n1*sin(theta1);
	mkl_theta0.imag = 0.0;
	vzDiv(1, &mkl_theta0, &mkl_n0, &mkl_theta0);  	//Calculate n1*sin(theta1)/n0
	vzAsin(1, &mkl_theta0, &mkl_theta0);			//Calculate asin(n1*sin(theta1)/n0)
	complex<double> theta0(mkl_theta0.real, mkl_theta0.imag);  //Store the result in theta0

	//Calculate the phase shift
	double phi = (4*PI*n2/lambda)*d2*cos(theta2);

	//Calculate the Fresnesl coefficient (perpendicular components) for the layer system (Si02, Si)
	complex<double> i(0,1);
	double k1 = 2*PI*n1/lambda;
	double l1 = k1*d1*cos(theta1);
	complex<double> p0 = n0*cos(theta0);
	double p1 = n1*cos(theta1);
	double p2 = n2*cos(theta2);
	complex<double> m11TE = cos(l1);
	complex<double> m12TE = -(i/p1)*sin(l1);
	complex<double> m21TE = -i*p1*sin(l1);
	complex<double> m22TE = cos(l1);

	complex<double> rTE = ((m11TE + m12TE*p0)*p2 - (m21TE + m22TE*p0)) /
			((m11TE + m12TE*p0)*p2 + (m21TE + m22TE*p0));

	double magSq_ifTE = abs(1. + rTE*exp(i*phi))*abs(1. + rTE*exp(i*phi));

	//Calculate the Fresnesl coefficient (parallel component) for the layer system (Si02, Si)
	complex<double> q0 = cos(theta0)/n0;
	double q1 = cos(theta1)/n1;
	double q2 = cos(theta2)/n2;

	complex<double> m11TM = cos(l1);
	complex<double> m12TM = -(i/q1)*sin(l1);
	complex<double> m21TM = -i*q1*sin(l1);
	complex<double> m22TM = cos(l1);

	complex<double> rTM = ((m11TM + m12TM*q0)*q2 - (m21TM + m22TM*q0)) /
			((m11TM + m12TM*q0)*q2 + (m21TM + m22TM*q0));


	double magSq_ifTM_p = abs(1. - rTM*exp(i*phi))*abs(1. - rTM*exp(i*phi));
	double magSq_ifTM_n = abs(1. + rTM*exp(i*phi))*abs(1. + rTM*exp(i*phi));

	//If the dye dipoles have defined orientations
	if (orientation == 1) {
		U = sin(thetaDye)*sin(thetaDye)*magSq_ifTE +
			sin(thetaDye)*sin(thetaDye)*cos(theta2)*cos(theta2)*magSq_ifTM_p +
			2*cos(thetaDye)*cos(thetaDye)*sin(theta2)*sin(theta2)*magSq_ifTM_n;

		return U*sin(theta2)*gsl_spline_eval(spectra_spline, lambda, spectra_acc);
	}

	//If the dye dipoles are randomly distributed
	U = magSq_ifTE + cos(theta2)*cos(theta2)*magSq_ifTM_p +	2*sin(theta2)*sin(theta2)*magSq_ifTM_n;

	return U*sin(theta2)*gsl_spline_eval(spectra_spline, lambda, spectra_acc);

}

double U_Em_Inttheta(double lambda, void* param) {


	double* dbl_point;
	dbl_point = (double*) param;
	double theta2Min = dbl_point[0];
	double theta2Max = dbl_point[1];
	double d2 = dbl_point[2];

	double parameters [] = {lambda, d2};

	double result, error;

	gsl_integration_workspace * w
	         = gsl_integration_workspace_alloc (500);


	gsl_function F;
	F.function = &U_Em;
    F.params = &parameters;

	gsl_integration_qag(&F, theta2Min, theta2Max, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;
}


double P_Em(double theta2Min, double theta2Max, double lambdaMin, double lambdaMax, double d2) {

	double param [] = {theta2Min, theta2Max, d2};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &U_Em_Inttheta;
	F.params = &param;

	gsl_integration_qag(&F, lambdaMin, lambdaMax, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;
}

double P_Ex_H (double d2, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double theta2 = dbl_point[0];
	double lambda = dbl_point[1];

	return P_Ex(theta2, lambda, d2);
}


double P_Em_H (double d2, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double theta2Min = dbl_point[0];
	double theta2Max = dbl_point[1];
	double lambdaMin = dbl_point[2];
	double lambdaMax = dbl_point[3];

	return P_Em(theta2Min, theta2Max, lambdaMin, lambdaMax, d2);
}


double P_Ex_Cylinder (double theta2, double lambda, double d2Min, double d2Max) {

	double param [] = {theta2, lambda};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &P_Ex_H;
	F.params = &param;

	gsl_integration_qag(&F, d2Min, d2Max, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;

}

double P_Ex_Gauss (double d2, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double theta2 = dbl_point[0];
	double lambda = dbl_point[1];
	double d2Mean = dbl_point[2];
	double sigmaSq = dbl_point[3];

	double guass = ( 1/(sqrt(2*PI*sigmaSq) )*exp( -(d2-d2Mean)*(d2-d2Mean)/(2*sigmaSq) ) );
	return guass*P_Ex(theta2, lambda, d2);
}

double P_Ex_Distribution (double theta2, double lambda, double d2Mean, double sigmaSq) {

	double param [] = {theta2, lambda, d2Mean, sigmaSq};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &P_Ex_Gauss;
	F.params = &param;

	double sigma = sqrt(sigmaSq);
	gsl_integration_qag(&F, d2Mean - 2*sigma, d2Mean + 2*sigma, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;

}

double P_Em_Cylinder (double theta2Min, double theta2Max, double lambdaMin, double lambdaMax, double d2Min, double d2Max) {

	double param [] = {theta2Min, theta2Max, lambdaMin, lambdaMax};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &P_Em_H;
	F.params = &param;

	gsl_integration_qag(&F, d2Min, d2Max, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;

}


double P_Ex_R (double r, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double theta2 = dbl_point[0];
	double lambda = dbl_point[1];
	double d2 = dbl_point[2];
	double alpha = dbl_point[3];

	return r*P_Ex(theta2, lambda, r*sin(alpha)+d2);
}


double P_Em_R (double r, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double theta2Min = dbl_point[0];
	double theta2Max = dbl_point[1];
	double lambdaMin = dbl_point[2];
	double lambdaMax = dbl_point[3];
	double d2 = dbl_point[4];
	double alpha = dbl_point[5];

	return r*P_Em(theta2Min, theta2Max, lambdaMin, lambdaMax, r*sin(alpha)+d2);
}

double P_Ex_Sphere_IntR (double alpha, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double theta2 = dbl_point[0];
	double lambda = dbl_point[1];
	double d2 = dbl_point[2];
	double r = dbl_point[3];

	double parameters [] = {theta2, lambda, d2, alpha};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &P_Ex_R;
	F.params = &parameters;

	gsl_integration_qag(&F, 0, r, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;
}

double P_Em_Sphere_IntR (double alpha, void* param) {

	double* dbl_point;
	dbl_point = (double*) param;
	double theta2Min = dbl_point[0];
	double theta2Max = dbl_point[1];
	double lambdaMin = dbl_point[2];
	double lambdaMax = dbl_point[3];
	double d2 = dbl_point[4];
	double r = dbl_point[5];

	double parameters [] = {theta2Min, theta2Max, lambdaMin, lambdaMax, d2, alpha};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &P_Em_R;
	F.params = &parameters;

	gsl_integration_qag(&F, 0, r, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;
}


double P_Ex_Sphere (double theta2, double lambda, double d2, double r, double alphaMin, double alphaMax) {

	double parameters [] = {theta2, lambda, d2, r};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &P_Ex_Sphere_IntR;
	F.params = &parameters;

	//Intergrate over alpha
	gsl_integration_qag(&F, alphaMin, alphaMax, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;

}

double P_Em_Sphere (double theta2Min, double theta2Max, double lambdaMin, double lambdaMax, double d2, double r, double alphaMin, double alphaMax) {

	double parameters [] = {theta2Min, theta2Max, lambdaMin, lambdaMax, d2, r};
	double result, error;

	gsl_integration_workspace * w
			= gsl_integration_workspace_alloc (500);

	gsl_function F;
	F.function = &P_Em_Sphere_IntR;
	F.params = &parameters;

	//integrate over alpha
	gsl_integration_qag(&F, alphaMin, alphaMax, 0.0, 1e-6, 500, 3, w, &result, &error);

	gsl_integration_workspace_free (w);

	return result;

}

double generateFLICCurves(double* ZGAP, double* FLIC, double* DERIV, int nimages) {

	int i, j, counter;
	double Pex;
	double *Pem;
	Pem = new double[FLIC_points];
	double max_I = -1.0;

	if (fit == "HAB" || fit == "HABL" || fit == "HABC" || fit == "HABCL" || fit == "HABCQ") {
		//Allocate ZGAP, the z-heights of the membrane that the FLIC intensities will be calculated
		//for
		for (i = 0; i<FLIC_points; i++) {
			ZGAP[i] = i*zGapSpacing + zGapMin;
		}

		//Calculate Pem for each height
		#pragma omp parallel for private(j)
		for (j=0; j < FLIC_points; j++) {
			if (usePem == 1) {
				cout << "\nCalculating Pem for FLIC...\n";
				if (model == "Point")
					Pem[j] = P_Em (0, thetaObjMax, lambdaEmMin, lambdaEmMax, ZGAP[j]);
				else if (model == "Cylinder")
					Pem[j] = P_Em_Cylinder (0, thetaObjMax, lambdaEmMin, lambdaEmMax, ZGAP[j]-(length/2), ZGAP[j]+(length/2));
				else if (model == "Sphere")
					Pem[j] = P_Em_Sphere (0, thetaObjMax, lambdaEmMin, lambdaEmMax, ZGAP[j], radius, -PI/2, PI/2);
				else cout << "Error model must be Point, Cylinder or Sphere";
				cout << "Pem[" << j << "]: " << Pem[j] << "\n";
			}
			else Pem[j] = 1.0;
		}

		//Loop through all the input parameters and calculate Pex and Pex*Pem
		cout << "Calculating Pex for FLIC...\n";
		#pragma omp parallel for private(i,j)
		for (i = 0; i < nimages; i++) {
			for (j = 0; j < FLIC_points; j++) {
				if (model == "Point")
					Pex = P_Ex(thetaLaser[i], lambdaEx, ZGAP[j]);
				else if (model == "Cylinder") {
					Pex = P_Ex_Cylinder (thetaLaser[i], lambdaEx, ZGAP[j]-(length/2), ZGAP[j]+(length/2));
					//Pex = P_Ex_Distribution (thetaLaser[i], lambdaEx, ZGAP[j], length);
				}
				else if (model == "Sphere")
					Pex = P_Ex_Sphere (thetaLaser[i], lambdaEx, ZGAP[j], radius, -PI/2, PI/2);
				else if (model == "Membrane")
					Pex = P_Ex_Fromherz(thetaLaser[i], lambdaEx, ZGAP[j]);
				else cout << "Error model must be Point, Cylinder, Sphere, or Membrane";

				FLIC[i*FLIC_points + j] = Pex*Pem[j];
			}
		}

		//Calculate the derivatives of the FLIC curves
		//Calculate Pem for each height - Deriv
		cout << "Calculating Pem for FLIC - Deriv...\n";
		#pragma omp parallel for private(j)
		for (j = 0; j < FLIC_points; j++) {
			if (usePem == 1) {
				if (model == "Point")
					Pem[j] = P_Em(0, thetaObjMax, lambdaEmMin, lambdaEmMax, ZGAP[j]+zGap_derivStep);
				else if (model == "Cylinder")
					Pem[j] = P_Em_Cylinder (0, thetaObjMax, lambdaEmMin, lambdaEmMax, ZGAP[j]-(length/2)+zGap_derivStep, ZGAP[j]+(length/2)+zGap_derivStep);
				else if (model == "Sphere")
					Pem[j] = P_Em_Sphere (0, thetaObjMax, lambdaEmMin, lambdaEmMax, ZGAP[j]+zGap_derivStep, radius, -PI/2, PI/2);
				else cout << "Error model must be Point, Cylinder or Sphere";
			}
			else Pem[j] = 1.0;
		}

		//Loop through all the input parameters and calculate Pex and Pex*Pem - Deriv
		cout << "Calculating Pex for FLIC - Deriv...\n";
		#pragma omp parallel for private(i,j)
		for (i = 0; i < nimages; i++) {
			for (j = 0; j < FLIC_points; j++) {
				if (model == "Point")
					Pex = P_Ex(thetaLaser[i], lambdaEx, ZGAP[j]+zGap_derivStep);
				else if (model == "Cylinder")
					Pex = P_Ex_Cylinder (thetaLaser[i], lambdaEx, ZGAP[j]-(length/2)+zGap_derivStep, ZGAP[j]+(length/2)+zGap_derivStep);
				else if (model == "Sphere")
					Pex = P_Ex_Sphere (thetaLaser[i], lambdaEx, ZGAP[j]+zGap_derivStep, radius, -PI/2, PI/2);
				else if (model == "Membrane")
					Pex = P_Ex_Fromherz(thetaLaser[i], lambdaEx, ZGAP[j]+zGap_derivStep);
				else cout << "Error model must be Point, Cylinder, Sphere, or Membrane";
				DERIV[i*FLIC_points + j] = (Pex*Pem[j] - FLIC[i*FLIC_points + j])/zGap_derivStep;
			}
		}
	}
	else if (fit == "HoAB") {
		//Allocate ZGAP, the z-heights of the membrane that the FLIC intensities will be calculated
		//for
		for (i = 0; i<FLIC_points; i++) {
			ZGAP[i] = i*zGapSpacing + zGapMin;
		}

		//Calculate Pem for each height
		cout << "\nCalculating Pem for FLIC...\n";
		//#pragma omp parallel for private(j)
		for (j=0; j < FLIC_points; j++) {
			if (usePem == 1) {
				d1 = ZGAP[j];
				if (model == "Point")
					Pem[j] = P_Em (0, thetaObjMax, lambdaEmMin, lambdaEmMax, 0);
				else if (model == "Cylinder")
					Pem[j] = P_Em_Cylinder (0, thetaObjMax, lambdaEmMin, lambdaEmMax, -length/2, length/2);
				else if (model == "Sphere")
					Pem[j] = P_Em_Sphere (0, thetaObjMax, lambdaEmMin, lambdaEmMax, 0, radius, -PI/2, PI/2);
				else cout << "Error model must be Point, Cylinder or Sphere";
			}
			else Pem[j] = 1.0;
		}

		//Loop through all the input parameters and calculate Pex and Pex*Pem
		cout << "Calculating Pex for FLIC...\n";
		//#pragma omp parallel for private(i,j)
		for (i = 0; i < nimages; i++) {
			for (j = 0; j < FLIC_points; j++) {
				d1 = ZGAP[j];
				if (model == "Point")
					Pex = P_Ex(thetaLaser[i], lambdaEx, 0);
				else if (model == "Cylinder")
					Pex = P_Ex_Cylinder (thetaLaser[i], lambdaEx, -length/2, length/2);
				else if (model == "Sphere")
					Pex = P_Ex_Sphere (thetaLaser[i], lambdaEx, 0, radius, -PI/2, PI/2);
				else cout << "Error model must be Point, Cylinder or Sphere";
				//cout

				FLIC[i*FLIC_points + j] = Pex*Pem[j];
			}
		}

		//Calculate the derivatives of the FLIC curves
		//Calculate Pem for each height - Deriv
		cout << "Calculating Pem for FLIC - Deriv...\n";
		//#pragma omp parallel for private(j)
		for (j = 0; j < FLIC_points; j++) {
			if (usePem == 1) {
				d1 = ZGAP[j];
				if (model == "Point")
					Pem[j] = P_Em(0, thetaObjMax, lambdaEmMin, lambdaEmMax, zGap_derivStep);
				else if (model == "Cylinder")
					Pem[j] = P_Em_Cylinder (0, thetaObjMax, lambdaEmMin, lambdaEmMax, -length/2 + zGap_derivStep, length/2 + zGap_derivStep);
				else if (model == "Sphere")
					Pem[j] = P_Em_Sphere (0, thetaObjMax, lambdaEmMin, lambdaEmMax, zGap_derivStep, radius, -PI/2, PI/2);
				else cout << "Error model must be Point, Cylinder or Sphere";
			}
			else Pem[j] = 1.0;
		}

		//Loop through all the input parameters and calculate Pex and Pex*Pem - Deriv
		cout << "Calculating Pex for FLIC - Deriv...\n";
		//#pragma omp parallel for private(i,j)
		for (i = 0; i < nimages; i++) {
			for (j = 0; j < FLIC_points; j++) {
				d1 = ZGAP[j];
				if (model == "Point")
					Pex = P_Ex(thetaLaser[i], lambdaEx, zGap_derivStep);
				else if (model == "Cylinder")
					Pex = P_Ex_Cylinder (thetaLaser[i], lambdaEx, -length/2 + zGap_derivStep, length/2 + zGap_derivStep);
				else if (model == "Sphere")
					Pex = P_Ex_Sphere (thetaLaser[i], lambdaEx, zGap_derivStep, radius, -PI/2, PI/2);
				else cout << "Error model must be Point, Cylinder or Sphere";
				DERIV[i*FLIC_points + j] = (Pex*Pem[j] - FLIC[i*FLIC_points + j])/zGap_derivStep;
			}
		}
	}
	else {
		cout << "FLIC curves can only be constructed for HAB and HoAB models!\n";
	}


	//Normalize the FLIC curves
	for (i = 0; i < nimages*FLIC_points; i++) {
		if (FLIC[i] > max_I) {
			max_I = FLIC[i];
		}
	}
	for (i = 0; i < nimages*FLIC_points; i++) {
		FLIC[i] = FLIC[i]/max_I;
		DERIV[i] = DERIV[i]/max_I;
	}

	//If want to output Pem unhighlight the following
	/*for (i = 0; i < nimages; i++) {
		for (j = 0; j < FLIC_points; j++) {
			FLIC[i*FLIC_points + j] = Pem[j];
		}
	}*/

	delete [] Pem;

	return max_I;
}




int localFLICfitter (double* Images, int nrows, int ncols, int nimages, double* ZGAP, double* FLIC, double* DERIV,
		double* H, double* A, double* B, double* L, double* R, int* F, string fit) {

	int i, j, pixIndex, flag;
	double Ho, Ao, Bo, Lo, Ro;

	for (i = 0; i < nrows; i++) {
		for (j = 0; j < ncols; j++) {

			pixIndex = getIndex(i, j, 0, nrows, ncols);

			if (F[pixIndex] == 0) {

				if (fit == "HAB"  || fit == "HoAB") {
					flag = nlsq_FLIC_HAB_pixel_MS (Images, pixIndex, nrows, ncols, nimages, ZGAP, FLIC, DERIV, Ho, Ao, Bo, Ro, H_min, H_max, MS_step);
					F[pixIndex] = flag; //its been processed

					if(flag == 1)  {  //successful calculation for pixIndex's height

						H[pixIndex] = Ho;
						R[pixIndex] = Ro;
						A[pixIndex] = Ao;
						B[pixIndex] = Bo;

						if (usecurves == 1) {
							if (report == 1 && pixIndex % 100 == 0)
								cout << "\nPixel: " << pixIndex << " row: " << i << " col: " << j << " H: " << Ho << " A: " << Ao << " B: " << Bo << " R: " << Ro;
						}
						else if (report == 1)
							cout << "\nPixel: " << pixIndex << " row: " << i << " col: " << j << " H: " << Ho << " A: " << Ao << " B: " << Bo << " R: " << Ro;

						if (Ho <= H_min|| Ho >= H_max)
							F[pixIndex] = -3;  //Did not converge within the boundary limits
					}
				}
				else if (fit == "HABC" || fit == "HABCL" || fit == "HABCQ") { //fit == HABC
					if (fit == "HABC" || fit == "HABCL")
						flag = nlsq_FLIC_HABC_pixel_MS (Images, pixIndex, nrows, ncols, nimages, ZGAP, FLIC, DERIV, Ho, Ao, Bo, Lo, Ro, H_min, H_max, MS_step);
					else
						flag = nlsq_FLIC_HABCQ_pixel_MS (Images, pixIndex, nrows, ncols, nimages, ZGAP, FLIC, DERIV, Ho, Ao, Bo, Lo, Ro, H_min, H_max, MS_step);

					F[pixIndex] = flag; //its been processed

					if(flag == 1)  {  //successful calculation for pixIndex's height

						H[pixIndex] = Ho;
						R[pixIndex] = Ro;
						A[pixIndex] = Ao;
						B[pixIndex] = Bo;
						L[pixIndex] = Lo;

						if (usecurves == 1) {
							if (report == 1 && pixIndex % 100 == 0)
								cout << "\nPixel1: " << pixIndex << " row: " << i << " col: " << j <<  " H: " << Ho << " A: " << Ao << " B: " << Bo << " C: " << Lo << " R: " << Ro;
						}

						else if (report == 1)
							cout << "\nPixel: " << pixIndex << " row: " << i << " col: " << j <<  " H: " << Ho << " A: " << Ao << " B: " << Bo << " C: " << Lo << " R: " << Ro;

						if (Ho <= H_min || Ho >= H_max)
							F[pixIndex] = -3;  //Did not converge within the boundary limits
					}
				}
				else { //fit == HABL
					flag = nlsq_FLIC_HABL_pixel_MS (Images, pixIndex, nrows, ncols, nimages, Ho, Ao, Bo, Lo, Ro, H_min, H_max, MS_step);
					F[pixIndex] = flag; //its been processed

					if(flag == 1)  {  //successful calculation for pixIndex's height

						H[pixIndex] = Ho;
						R[pixIndex] = Ro;
						A[pixIndex] = Ao;
						B[pixIndex] = Bo;
						L[pixIndex] = Lo;

						if (report == 1)
							cout << "\nPixel: " << pixIndex << " H: " << Ho << " A: " << Ao << " B: " << Bo << " L: " << Lo << " R: " << Ro;

						if (Ho <= H_min || Ho >= H_max)
							F[pixIndex] = -3;  //Did not converge within the boundary limits
					}
				}
			}
		}
	}
	return 1;
}

int localFLICfitterConstrained (double* Images, int pixIndex, int nrows, int ncols, int nimages, double* ZGAP, double* FLIC, double* DERIV,
		double* H, double* A, double* B, double* L, double* R, int* F, int constraint, double maxChange, string fit) {


	int m[8];  // Holds the row number for neighbor pixels
	int n[8];	// Holds the column number for neighbor pixels
	int nneighbors;  //The number of neighbors
	int index;
	int i, flag, row, col;
	double Ho, Ao, Bo, Ro, Lo;
	double h_LB;
	double h_UB;
	double max, min;

	//Find the neighbors of the start pixel
	col = getCol(pixIndex, ncols);
	row = getRow(pixIndex, ncols);
	nneighbors = getNeighbors(m, n, row, col, 1, nrows, ncols);

	//Calculate the height constraints on the pixel to be processed based on
	//the heights of its neighbors that have been processed
	h_LB = H_min;
	h_UB = H_max;

	//Determine the constrained upper and lower bounds
	if (constraint == 1) {  //Highest possible lowerbound and lowest upperbound
		for (i = 0; i < nneighbors; i++) {
			index = getIndex(m[i], n[i], 0, nrows, ncols);
			if (F[index] == 1) {
				if (H[index] - maxChange > h_LB )
					h_LB = H[index] - maxChange;

				if (H[index] + maxChange < h_UB)
					h_UB = H[index] + maxChange;
			}
		}
	}

	else if (constraint == 2) {  //Lowest constrained lowerbound and highest upperbound
		i = 0;
		while (i < nneighbors && F[ getIndex(m[i], n[i], 0, nrows, ncols) ] != 1) i++;
		if ( i < nneighbors) {
			index = getIndex(m[i], n[i], 0, nrows, ncols);
			h_LB = H[index] - maxChange;
			h_UB = H[index] + maxChange;
			i++;
			while (i < nneighbors) {
				index = getIndex(m[i], n[i], 0, nrows, ncols);
				if (F[index] == 1) {
					if (H[index] - maxChange < h_LB )
						h_LB = H[index] - maxChange;

					if (H[index] + maxChange > h_UB)
						h_UB = H[index] + maxChange;
				}
				i++;
			}
			if (h_LB < H_min)
				h_LB = H_min;
			if (h_UB > H_max)
				h_UB = H_max;
		}
	}

	//Calculate the height of the start pixel
	if (fit == "HAB" || fit == "HABL" || fit == "HoAB") {
		flag = nlsq_FLIC_HAB_pixel_MS (Images, pixIndex, nrows, ncols, nimages, ZGAP, FLIC, DERIV, Ho, Ao, Bo, Ro, h_LB, h_UB, MS_step);
		F[pixIndex] = flag; //its been processed


		if(flag == 1)  {  //successful calculation for pixIndex's height

			H[pixIndex] = Ho;
			R[pixIndex] = Ro;
			A[pixIndex] = Ao;
			B[pixIndex] = Bo;
			if (report == 1 && pixIndex % 100 == 0)
				cout << "\nPixel: " << pixIndex << " H: " << Ho << " A: " << Ao << " B: " << Bo << " R: " << Ro;

			if (Ho <= h_LB || Ho >= h_UB)
				F[pixIndex] = -3;  //Did not converge within the boundary limits
		}
		else {
		return flag; // unsuccessful
		}
	}
	else { //Four parameter model

		flag = nlsq_FLIC_HABL_pixel_MS (Images, pixIndex, nrows, ncols, nimages, Ho, Ao, Bo, Lo, Ro, h_LB, h_UB, MS_step);
		F[pixIndex] = flag; //its been processed

		if(flag == 1)  {  //successful calculation for pixIndex's height

			H[pixIndex] = Ho;
			R[pixIndex] = Ro;
			A[pixIndex] = Ao;
			B[pixIndex] = Bo;
			L[pixIndex] = Lo;
			if (report == 1 && pixIndex % 100 == 0)
				cout << "\nPixel: " << pixIndex << " H: " << Ho << " A: " << Ao << " B: " << Bo << " L: " << Lo << " R: " << Ro;

			if (Ho <= h_LB || Ho >= h_UB)
				F[pixIndex] = -3;  //Did not converge within the boundary limits
		}
		else {
		return flag; // unsuccessful
		}

	}

	//Calculate the heights of the start pixels nearest neighbors that have not yet been processed
	i = 0;
	while ( i < nneighbors ) {

		index = getIndex(m[i], n[i], 0, nrows, ncols);
		if (F[index] == 0 && flag != -1) {
			flag = localFLICfitterConstrained(Images, index, nrows, ncols, nimages, ZGAP, FLIC, DERIV, H, A, B, L, R, F, constraint, maxChange, fit);
		}
		i++;
	}

	return flag;
}


int nlsq_FLIC_HAB_pixel_MS (double* Images, int pixel, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double& H, double& A, double& B, double& R, double h_LB, double h_UB, double stepSize)
{
	//***********************************Variables, etc*******************************************

	int i;		//counters
	double h_best, A_best, B_best;	//The best multi-start solution for h, A, and B
	double r_min;			//Holds the lowest residual from the multi-start solutions
	double MS_start;
	int flag;
	int iMax;
	int success = 0;

	iMax = ceil( (h_UB - h_LB)/stepSize );

	//Start a multi-start approach to find the best height
	r_min = numeric_limits<double>::infinity();
	for (i = 0; i < iMax; i++) {

		H = i*stepSize + h_LB;

		if (usecurves == 1) {
			flag = nlsq_FLIC_HAB_pixel(Images, pixel, nrows, ncols, nimages, ZGAP,
				FLIC, DERIV, H, A, B, R, h_LB, h_UB);
		}
		else {
			flag = nlsq_FLIC_HAB_pixelNC(Images, pixel, nrows, ncols, nimages, H, A, B, R, h_LB, h_UB);
		}

		//Check to see if the solution is better than previous multi-start solutions
		if (flag == 1) {  //Returned successful
			if (R < r_min) {
				h_best = H;
				A_best = A;
				B_best = B;
				r_min = R;
			}
			if (success != 1) success = 1;
		}
		else if (flag == -1) //Catastrophic error in mkl solver
			return -1;
	}

	H = h_best;
	A = A_best;
	B = B_best;
	R = r_min;

	if (success == 1)
		return 1;  //successful
	else {
		cout << "failure:";
		return -2;  //Never converged to a solution
	}
}

int nlsq_FLIC_HABL_pixel_MS (double* Images, int pixel, int nrows, int ncols, int nimages, double& H, double& A, double& B,
		double &L, double& R, double h_LB, double h_UB, double stepSize)
{
	//***********************************Variables, etc*******************************************

	int i;		//counters
	double h_best, A_best, B_best, L_best;	//The best multi-start solution for h, A, and B
	double r_min;			//Holds the lowest residual from the multi-start solutions
	double MS_start;
	int flag;
	int iMax;
	int success = 0;

	iMax = ceil( (h_UB - h_LB)/stepSize );

	//Start a multi-start approach to find the best height
	r_min = numeric_limits<double>::infinity();
	for (i = 0; i < iMax; i++) {

		H = i*stepSize + h_LB;

		flag = nlsq_FLIC_HABL_pixelNC(Images, pixel, nrows, ncols, nimages, H, A, B, L, R, h_LB, h_UB);

		//Check to see if the solution is better than previous multi-start solutions
		if (flag == 1) {  //Returned successful
			if (R < r_min) {
				h_best = H;
				A_best = A;
				B_best = B;
				L_best = L;
				r_min = R;
			}
			if (success != 1) success = 1;
		}
		else if (flag == -1) //Catastrophic error in mkl solver
			return -1;
	}

	H = h_best;
	A = A_best;
	B = B_best;
	L = L_best;
	R = r_min;

	if (success == 1)
		return 1;  //successful
	else {
		cout << "failure:";
		return -2;  //Never converged to a solution
	}
}

int nlsq_FLIC_HABC_pixel_MS (double* Images, int pixel, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double& H, double& A, double& B, double& L, double& R, double h_LB, double h_UB, double stepSize)
{
	//***********************************Variables, etc*******************************************

	int i;		//counters
	double h_best, A_best, B_best, L_best;	//The best multi-start solution for h, A, and B
	double r_min;			//Holds the lowest residual from the multi-start solutions
	double MS_start;
	int flag;
	int iMax;
	int success = 0;

	iMax = ceil( (h_UB - h_LB)/stepSize );

	//Start a multi-start approach to find the best height
	r_min = numeric_limits<double>::infinity();
	for (i = 0; i < iMax; i++) {

		H = i*stepSize + h_LB;

		flag = nlsq_FLIC_HABC_pixel(Images, pixel, nrows, ncols, nimages, ZGAP,
			FLIC, DERIV, H, A, B, L, R, h_LB, h_UB);

		//Check to see if the solution is better than previous multi-start solutions
		if (flag == 1) {  //Returned successful
			if (R < r_min) {
				h_best = H;
				A_best = A;
				B_best = B;
				L_best = L;
				r_min = R;
			}
			if (success != 1) success = 1;
		}
		else if (flag == -1) //Catastrophic error in mkl solver
			return -1;
	}

	H = h_best;
	A = A_best;
	B = B_best;
	L = L_best;
	R = r_min;

	if (success == 1)
		return 1;  //successful
	else {
		cout << "failure:";
		return -2;  //Never converged to a solution
	}
}

int nlsq_FLIC_HABCQ_pixel_MS (double* Images, int pixel, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double& H, double& A, double& B, double& L, double& R, double h_LB, double h_UB, double stepSize)
{
	//***********************************Variables, etc*******************************************

	int i;		//counters
	double h_best, A_best, B_best, L_best;	//The best multi-start solution for h, A, and B
	double r_min;			//Holds the lowest residual from the multi-start solutions
	double MS_start;
	int flag;
	int iMax;
	int success = 0;

	iMax = ceil( (h_UB - h_LB)/stepSize );

	//Start a multi-start approach to find the best height
	r_min = numeric_limits<double>::infinity();
	for (i = 0; i < iMax; i++) {

		H = i*stepSize + h_LB;

		flag = nlsq_FLIC_HABCQ_pixel(Images, pixel, nrows, ncols, nimages, ZGAP,
			FLIC, DERIV, H, A, B, L, R, h_LB, h_UB);

		//Check to see if the solution is better than previous multi-start solutions
		if (flag == 1) {  //Returned successful
			if (R < r_min) {
				h_best = H;
				A_best = A;
				B_best = B;
				L_best = L;
				r_min = R;
			}
			if (success != 1) success = 1;
		}
		else if (flag == -1) //Catastrophic error in mkl solver
			return -1;
	}

	H = h_best;
	A = A_best;
	B = B_best;
	L = L_best;
	R = r_min;

	if (success == 1)
		return 1;  //successful
	else {
		cout << "failure:";
		return -2;  //Never converged to a solution
	}
}

int nlsq_FLIC_HAB_pixel(double* Images, int pixel, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double& H, double& A, double& B, double& R, double h_LB, double h_UB)
{
	//***********************************Variables, etc*******************************************
	MKL_INT n = 3;			//number of function variables (height of pixel, A, B)
	MKL_INT m = nimages;	//dimension of function value (number of equations)
	double	eps[6];			// precisions for stop-criteria (see manual for more details
	double	*x;				// solution vector. contains values x for f(x)
	MKL_INT	iter1 = 1000;	//maximum number of iterations
	MKL_INT	iter2 = 100;	//maximum number of iterations of calculation of trial-step
	double	rs = 0.0;		//initial step bound
	MKL_INT RCI_Request;	//reverse communication interface parameter
	MKL_INT successful;		//controls of rci cycle
	double *fvec;			//function (f(x)) value vector
	double *fobs;			//The observed value for each function
	double *fjac;			//jacobi matrix
	double	*LW, *UP;		//lower and upper bounds
	MKL_INT iter;			//number of iterations
	MKL_INT st_cr;			//number of stop-criterion
	double r1, r2;			//initial and final residuals
	_TRNSPBC_HANDLE_t handle;	//TR solver handle
	int NN_row [9];  	//Storage of the row numbers of nearest neighbor pixels
	int NN_col [9];		//Storage of column numbers of nearest neighbor pixels
	int num_NN;				//The number of neighbors for a given pixel
	MKL_INT row, col, i, j, k;		//counters


	//memory allocation
	x = new double[n];
	fvec = new double[m];
	fobs = new double[m];
	fjac = new double[m*n];
	LW = new double[n];
	UP = new double[n];

	//set precisions for stop-criteria
	for (i = 0; i < 6; i++)
	{
		eps [i] = 0.0000001;
	}

	//set bounds
	LW [0] = h_LB;
	LW [1] = A_min;
	LW [2] = B_min;
	UP [0] = h_UB;
	UP [1] = A_max;
	UP [2] = B_max;


	//Loop through all the pixels and calculate the best estimate of the height for each pixel
	row = getRow(pixel, ncols);
	col = getCol(pixel, ncols);

	//Get the nearest neighbor pixels
	num_NN = getNeighbors(NN_row, NN_col, row, col, 0, nrows, ncols);

	//Compute fobs
	for (i = 0; i < num_angles; i++) {
		fobs[i] = 0.0;
		for (j = 0; j < num_NN; j++) {
			fobs[i] = fobs[i] + Images[getIndex(NN_row[j], NN_col[j], i, nrows, ncols)];
		}
		fobs[i] = fobs[i]/num_NN;
		//cout << "fobs[" << i << "]: " << fobs[i] << "\n";
	}

	//Set the initial guess
	x[0] = H;
	x[1] = A_guess;
	x[2] = B_guess;

	//set initial values
	for (i = 0; i < m; i++)
		fvec [i] = 0.0;
	for (i = 0; i < m*n; i++)
		fjac [i] = 0.0;


	//***********************Solve for the best height, A, and B********************************

	/* initialize solver (allocate mamory, set initial values)
		handle	in/out:	TR solver handle
		n       in:     number of function variables
		m       in:     dimension of function value
		x       in:     solution vector. contains values x for f(x)
		LW		in:		lower bound
		UP		in:		upper bound
		eps     in:     precisions for stop-criteria
		iter1   in:     maximum number of iterations
		iter2   in:     maximum number of iterations of calculation of trial-step
		rs      in:     initial step bound */
	if (dtrnlspbc_init (&handle, &n, &m, x, LW, UP, eps, &iter1, &iter2, &rs) !=
		TR_SUCCESS)
	{
		// Exit if unsuccessful
		cout << "| error in dtrnlspbc_init\n";
		return 0;
	}

	//set initial rci cycle variables
	RCI_Request = 0;
	successful = 0;

	//rci cycle
	while (successful == 0)
	{
		//cout << "here1";
		/* call tr solver
			handle		in/out:	tr solver handle
			fvec		in:     vector
			fjac		in:     jacobi matrix
			RCI_request in/out:	return number which denote next step for performing */
		if (dtrnlspbc_solve (&handle, fvec, fjac, &RCI_Request) != TR_SUCCESS)
		{
			// Exit if unsuccessful
			cout << "| error in dtrnlspbc_solve\n";
			return -1;
		}

		//Exit if the solution is infeasible

		if ( isnan(x[0]) || isnan(x[1]) || isnan(x[2]) ) {

			// Exit if unsuccessful
			cout << "| Solver returned NAN\n";
			return -2;
		}

		// according with rci_request value we do next step
		if (RCI_Request == -1 ||
			RCI_Request == -2 ||
			RCI_Request == -3 ||
			RCI_Request == -4 ||
			RCI_Request == -5 ||
			RCI_Request == -6)
			// exit rci cycle
			successful = 1;

		if (RCI_Request == 1)
		{
			for (i = 0; i < m; i++) {
				fvec[i] = x[1]*interpolateFLIC(ZGAP, &FLIC[i*FLIC_points], zGapSpacing, FLIC_points, x[0]) + x[2] - fobs[i];
			}
		}
		if (RCI_Request == 2)
		{
			for (i = 0; i < m; i++) {
				fjac[i] = x[1]*interpolateFLIC(ZGAP, &DERIV[i*FLIC_points], zGapSpacing, FLIC_points, x[0]);
				fjac[m + i] = interpolateFLIC(ZGAP, &FLIC[i*FLIC_points], zGapSpacing, FLIC_points, x[0]);
				fjac[2*m + i] = 1;
			}

		}
	}

	/* get solution statuses
		handle            in:	TR solver handle
		iter              out:	number of iterations
		st_cr             out:	number of stop criterion
		r1                out:	initial residuals
		r2                out:	final residuals */
	if (dtrnlspbc_get (&handle, &iter, &st_cr, &r1, &r2) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_get\n";
		return -1;
	}

	//******************End of Solve for the best height, A, and B****************************

	//Check to see if the solution is better than previous multi-start solutions
	H = x[0];
	A = x[1];
	B = x[2];
	R = r2;

	/* free allocated memory */
	delete [] x;
	delete [] fvec;
	delete [] fjac;
	delete [] fobs;
	delete [] LW;
	delete [] UP;

	// free handle memory
	if (dtrnlspbc_delete (&handle) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_delete\n";
		return -1;
	}

	return 1;  //successful
}

int nlsq_FLIC_HABC_pixel(double* Images, int pixel, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double& H, double& A, double& B, double& L, double& R, double h_LB, double h_UB)
{
	//***********************************Variables, etc*******************************************
	MKL_INT n = 4;			//number of function variables (height of pixel, A, B, C)
	MKL_INT m = nimages;	//dimension of function value (number of equations)
	double	eps[6];			// precisions for stop-criteria (see manual for more details
	double	*x;				// solution vector. contains values x for f(x)
	MKL_INT	iter1 = 1000;	//maximum number of iterations
	MKL_INT	iter2 = 100;	//maximum number of iterations of calculation of trial-step
	double	rs = 0.0;		//initial step bound
	MKL_INT RCI_Request;	//reverse communication interface parameter
	MKL_INT successful;		//controls of rci cycle
	double *fvec;			//function (f(x)) value vector
	double *fobs;			//The observed value for each function
	double *fjac;			//jacobi matrix
	double	*LW, *UP;		//lower and upper bounds
	MKL_INT iter;			//number of iterations
	MKL_INT st_cr;			//number of stop-criterion
	double r1, r2;			//initial and final residuals
	_TRNSPBC_HANDLE_t handle;	//TR solver handle
	int NN_row [9];  	//Storage of the row numbers of nearest neighbor pixels
	int NN_col [9];		//Storage of column numbers of nearest neighbor pixels
	int num_NN;				//The number of neighbors for a given pixel
	MKL_INT row, col, i, j, k;		//counters


	//memory allocation
	x = new double[n];
	fvec = new double[m];
	fobs = new double[m];
	fjac = new double[m*n];
	LW = new double[n];
	UP = new double[n];

	//set precisions for stop-criteria
	for (i = 0; i < 6; i++)
	{
		eps [i] = 0.0000001;
	}

	//set bounds
	LW [0] = h_LB;
	LW [1] = A_min;
	LW [2] = B_min;
	LW [3] = L_min;
	UP [0] = h_UB;
	UP [1] = A_max;
	UP [2] = B_max;
	UP [3] = L_max;


	//*********Loop through all the pixels and calculate the best estimate of the height for each pixel*****************

	//Get the row and column number
	row = getRow(pixel, ncols);
	col = getCol(pixel, ncols);

	//Get the nearest neighbor pixels
	num_NN = getNeighbors(NN_row, NN_col, row, col, 0, nrows, ncols);

	//Compute fobs
	for (i = 0; i < num_angles; i++) {
		fobs[i] = 0.0;
		for (j = 0; j < num_NN; j++) {
			fobs[i] = fobs[i] + Images[getIndex(NN_row[j], NN_col[j], i, nrows, ncols)];
		}
		fobs[i] = fobs[i]/num_NN;
		//cout << "fobs[" << i << "]: " << fobs[i] << "\n";
	}

	//Set the initial guess
	x[0] = H;
	x[1] = A_guess;
	x[2] = B_guess;
	x[3] = L_guess;

	//set initial values
	for (i = 0; i < m; i++)
		fvec [i] = 0.0;
	for (i = 0; i < m*n; i++)
		fjac [i] = 0.0;


	//***********************Solve for the best height, A, and B********************************

	/* initialize solver (allocate mamory, set initial values)
		handle	in/out:	TR solver handle
		n       in:     number of function variables
		m       in:     dimension of function value
		x       in:     solution vector. contains values x for f(x)
		LW		in:		lower bound
		UP		in:		upper bound
		eps     in:     precisions for stop-criteria
		iter1   in:     maximum number of iterations
		iter2   in:     maximum number of iterations of calculation of trial-step
		rs      in:     initial step bound */
	if (dtrnlspbc_init (&handle, &n, &m, x, LW, UP, eps, &iter1, &iter2, &rs) !=
		TR_SUCCESS)
	{
		// Exit if unsuccessful
		cout << "| error in dtrnlspbc_init\n";
		return 0;
	}

	//set initial rci cycle variables
	RCI_Request = 0;
	successful = 0;

	//rci cycle
	while (successful == 0)
	{
		//cout << "here1";
		/* call tr solver
			handle		in/out:	tr solver handle
			fvec		in:     vector
			fjac		in:     jacobi matrix
			RCI_request in/out:	return number which denote next step for performing */
		if (dtrnlspbc_solve (&handle, fvec, fjac, &RCI_Request) != TR_SUCCESS)
		{
			// Exit if unsuccessful
			cout << "| error in dtrnlspbc_solve\n";
			return -1;
		}

		//Exit if the solution is infeasible

		if ( isnan(x[0]) || isnan(x[1]) || isnan(x[2]) || isnan(x[3]) ) {

			// Exit if unsuccessful
			cout << "| Solver returned NAN\n";
			return -2;
		}

		// according with rci_request value we do next step
		if (RCI_Request == -1 ||
			RCI_Request == -2 ||
			RCI_Request == -3 ||
			RCI_Request == -4 ||
			RCI_Request == -5 ||
			RCI_Request == -6)
			// exit rci cycle
			successful = 1;

		if (RCI_Request == 1)
		{
			for (i = 0; i < m; i++) {
				fvec[i] = x[1]*interpolateFLIC(ZGAP, &FLIC[i*FLIC_points], zGapSpacing, FLIC_points, x[0]) + x[2] + x[3]*thetaLaser[i] - fobs[i];
			}
		}
		if (RCI_Request == 2)
		{
			for (i = 0; i < m; i++) {
				fjac[i] = x[1]*interpolateFLIC(ZGAP, &DERIV[i*FLIC_points], zGapSpacing, FLIC_points, x[0]);
				fjac[m + i] = interpolateFLIC(ZGAP, &FLIC[i*FLIC_points], zGapSpacing, FLIC_points, x[0]);
				fjac[2*m + i] = 1;
				fjac[3*m + i] = thetaLaser[i];
			}

		}
	}

	/* get solution statuses
		handle            in:	TR solver handle
		iter              out:	number of iterations
		st_cr             out:	number of stop criterion
		r1                out:	initial residuals
		r2                out:	final residuals */
	if (dtrnlspbc_get (&handle, &iter, &st_cr, &r1, &r2) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_get\n";
		return -1;
	}

	//******************End of Solve for the best height, A, and B****************************

	//Check to see if the solution is better than previous multi-start solutions
	H = x[0];
	A = x[1];
	B = x[2];
	L = x[3];
	R = r2;

	/* free allocated memory */
	delete [] x;
	delete [] fvec;
	delete [] fjac;
	delete [] fobs;
	delete [] LW;
	delete [] UP;

	// free handle memory
	if (dtrnlspbc_delete (&handle) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_delete\n";
		return -1;
	}

	return 1;  //successful
}

int nlsq_FLIC_HABCQ_pixel(double* Images, int pixel, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double& H, double& A, double& B, double& L, double& R, double h_LB, double h_UB)
{
	//***********************************Variables, etc*******************************************
	MKL_INT n = 4;			//number of function variables (height of pixel, A, B, C)
	MKL_INT m = nimages;	//dimension of function value (number of equations)
	double	eps[6];			// precisions for stop-criteria (see manual for more details
	double	*x;				// solution vector. contains values x for f(x)
	MKL_INT	iter1 = 1000;	//maximum number of iterations
	MKL_INT	iter2 = 100;	//maximum number of iterations of calculation of trial-step
	double	rs = 0.0;		//initial step bound
	MKL_INT RCI_Request;	//reverse communication interface parameter
	MKL_INT successful;		//controls of rci cycle
	double *fvec;			//function (f(x)) value vector
	double *fobs;			//The observed value for each function
	double *fjac;			//jacobi matrix
	double	*LW, *UP;		//lower and upper bounds
	MKL_INT iter;			//number of iterations
	MKL_INT st_cr;			//number of stop-criterion
	double r1, r2;			//initial and final residuals
	_TRNSPBC_HANDLE_t handle;	//TR solver handle
	int NN_row [9];  	//Storage of the row numbers of nearest neighbor pixels
	int NN_col [9];		//Storage of column numbers of nearest neighbor pixels
	int num_NN;				//The number of neighbors for a given pixel
	MKL_INT row, col, i, j, k;		//counters


	//memory allocation
	x = new double[n];
	fvec = new double[m];
	fobs = new double[m];
	fjac = new double[m*n];
	LW = new double[n];
	UP = new double[n];

	//set precisions for stop-criteria
	for (i = 0; i < 6; i++)
	{
		eps [i] = 0.0000001;
	}

	//set bounds
	LW [0] = h_LB;
	LW [1] = A_min;
	LW [2] = B_min;
	LW [3] = L_min;
	UP [0] = h_UB;
	UP [1] = A_max;
	UP [2] = B_max;
	UP [3] = L_max;


	//*********Loop through all the pixels and calculate the best estimate of the height for each pixel*****************

	//Get the row and column number
	row = getRow(pixel, ncols);
	col = getCol(pixel, ncols);

	//Get the nearest neighbor pixels
	num_NN = getNeighbors(NN_row, NN_col, row, col, 0, nrows, ncols);

	//Compute fobs
	for (i = 0; i < num_angles; i++) {
		fobs[i] = 0.0;
		for (j = 0; j < num_NN; j++) {
			fobs[i] = fobs[i] + Images[getIndex(NN_row[j], NN_col[j], i, nrows, ncols)];
		}
		fobs[i] = fobs[i]/num_NN;
		//cout << "fobs[" << i << "]: " << fobs[i] << "\n";
	}

	//Set the initial guess
	x[0] = H;
	x[1] = A_guess;
	x[2] = B_guess;
	x[3] = L_guess;

	//set initial values
	for (i = 0; i < m; i++)
		fvec [i] = 0.0;
	for (i = 0; i < m*n; i++)
		fjac [i] = 0.0;


	//***********************Solve for the best height, A, and B********************************

	/* initialize solver (allocate mamory, set initial values)
		handle	in/out:	TR solver handle
		n       in:     number of function variables
		m       in:     dimension of function value
		x       in:     solution vector. contains values x for f(x)
		LW		in:		lower bound
		UP		in:		upper bound
		eps     in:     precisions for stop-criteria
		iter1   in:     maximum number of iterations
		iter2   in:     maximum number of iterations of calculation of trial-step
		rs      in:     initial step bound */
	if (dtrnlspbc_init (&handle, &n, &m, x, LW, UP, eps, &iter1, &iter2, &rs) !=
		TR_SUCCESS)
	{
		// Exit if unsuccessful
		cout << "| error in dtrnlspbc_init\n";
		return 0;
	}

	//set initial rci cycle variables
	RCI_Request = 0;
	successful = 0;

	//rci cycle
	while (successful == 0)
	{
		//cout << "here1";
		/* call tr solver
			handle		in/out:	tr solver handle
			fvec		in:     vector
			fjac		in:     jacobi matrix
			RCI_request in/out:	return number which denote next step for performing */
		if (dtrnlspbc_solve (&handle, fvec, fjac, &RCI_Request) != TR_SUCCESS)
		{
			// Exit if unsuccessful
			cout << "| error in dtrnlspbc_solve\n";
			return -1;
		}

		//Exit if the solution is infeasible

		if ( isnan(x[0]) || isnan(x[1]) || isnan(x[2]) || isnan(x[3]) ) {

			// Exit if unsuccessful
			cout << "| Solver returned NAN\n";
			return -2;
		}

		// according with rci_request value we do next step
		if (RCI_Request == -1 ||
			RCI_Request == -2 ||
			RCI_Request == -3 ||
			RCI_Request == -4 ||
			RCI_Request == -5 ||
			RCI_Request == -6)
			// exit rci cycle
			successful = 1;

		if (RCI_Request == 1)
		{
			for (i = 0; i < m; i++) {
				fvec[i] = x[1]*interpolateFLIC(ZGAP, &FLIC[i*FLIC_points], zGapSpacing, FLIC_points, x[0]) + x[2] + x[3]*thetaLaser[i]*thetaLaser[i] - fobs[i];

			}
		}
		if (RCI_Request == 2)
		{
			for (i = 0; i < m; i++) {
				fjac[i] = x[1]*interpolateFLIC(ZGAP, &DERIV[i*FLIC_points], zGapSpacing, FLIC_points, x[0]);
				fjac[m + i] = interpolateFLIC(ZGAP, &FLIC[i*FLIC_points], zGapSpacing, FLIC_points, x[0]);
				fjac[2*m + i] = 1;
				fjac[3*m + i] = thetaLaser[i]*thetaLaser[i];
			}

		}
	}

	/* get solution statuses
		handle            in:	TR solver handle
		iter              out:	number of iterations
		st_cr             out:	number of stop criterion
		r1                out:	initial residuals
		r2                out:	final residuals */
	if (dtrnlspbc_get (&handle, &iter, &st_cr, &r1, &r2) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_get\n";
		return -1;
	}

	//******************End of Solve for the best height, A, and B****************************

	//Check to see if the solution is better than previous multi-start solutions
	H = x[0];
	A = x[1];
	B = x[2];
	L = x[3];
	R = r2;

	/* free allocated memory */
	delete [] x;
	delete [] fvec;
	delete [] fjac;
	delete [] fobs;
	delete [] LW;
	delete [] UP;

	// free handle memory
	if (dtrnlspbc_delete (&handle) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_delete\n";
		return -1;
	}

	return 1;  //successful
}


int nlsq_FLIC_HAB_pixelNC (double* Images, int pixel, int nrows, int ncols, int nimages, double& H, double& A, double& B, double& R, double h_LB, double h_UB)
{
	//***********************************Variables, etc*******************************************
	MKL_INT n = 3;			//number of function variables (height of pixel, A, B)
	MKL_INT m = nimages;	//dimension of function value (number of equations)
	double	eps[6];			// precisions for stop-criteria (see manual for more details
	double	*x;				// solution vector. contains values x for f(x)
	MKL_INT	iter1 = 1000;	//maximum number of iterations
	MKL_INT	iter2 = 100;	//maximum number of iterations of calculation of trial-step
	double	rs = 0.0;		//initial step bound
	MKL_INT RCI_Request;	//reverse communication interface parameter
	MKL_INT successful;		//controls of rci cycle
	double *fvec;			//function (f(x)) value vector
	double *fobs;			//The observed value for each function
	double *fjac;			//jacobi matrix
	double	*LW, *UP;		//lower and upper bounds
	MKL_INT iter;			//number of iterations
	MKL_INT st_cr;			//number of stop-criterion
	double r1, r2;			//initial and final residuals
	_TRNSPBC_HANDLE_t handle;	//TR solver handle
	int NN_row [9];  	//Storage of the row numbers of nearest neighbor pixels
	int NN_col [9];		//Storage of column numbers of nearest neighbor pixels
	int num_NN;				//The number of neighbors for a given pixel
	MKL_INT row, col, i, j, k;		//counters


	//memory allocation
	x = new double[n];
	fvec = new double[m];
	fobs = new double[m];
	fjac = new double[m*n];
	LW = new double[n];
	UP = new double[n];

	//set precisions for stop-criteria
	for (i = 0; i < 6; i++)
	{
		eps [i] = 0.0000001;
	}

	//set bounds
	LW [0] = h_LB;
	LW [1] = A_min;
	LW [2] = B_min;
	UP [0] = h_UB;
	UP [1] = A_max;
	UP [2] = B_max;


	//Loop through all the pixels and calculate the best estimate of the height for each pixel
	row = getRow(pixel, ncols);
	col = getCol(pixel, ncols);

	//Get the nearest neighbor pixels
	num_NN = getNeighbors(NN_row, NN_col, row, col, 0, nrows, ncols);

	//Compute fobs
	for (i = 0; i < num_angles; i++) {
		fobs[i] = 0.0;
		for (j = 0; j < num_NN; j++) {
			fobs[i] = fobs[i] + Images[getIndex(NN_row[j], NN_col[j], i, nrows, ncols)];
		}
		fobs[i] = fobs[i]/num_NN;
		//cout << "fobs[" << i << "]: " << fobs[i] << "\n";
	}

	//Set the initial guess
	x[0] = H;
	x[1] = A_guess;
	x[2] = B_guess;

	//set initial values
	for (i = 0; i < m; i++)
		fvec [i] = 0.0;
	for (i = 0; i < m*n; i++)
		fjac [i] = 0.0;


	//***********************Solve for the best height, A, and B********************************

	/* initialize solver (allocate mamory, set initial values)
		handle	in/out:	TR solver handle
		n       in:     number of function variables
		m       in:     dimension of function value
		x       in:     solution vector. contains values x for f(x)
		LW		in:		lower bound
		UP		in:		upper bound
		eps     in:     precisions for stop-criteria
		iter1   in:     maximum number of iterations
		iter2   in:     maximum number of iterations of calculation of trial-step
		rs      in:     initial step bound */
	if (dtrnlspbc_init (&handle, &n, &m, x, LW, UP, eps, &iter1, &iter2, &rs) !=
		TR_SUCCESS)
	{
		// Exit if unsuccessful
		cout << "| error in dtrnlspbc_init\n";
		return 0;
	}

	//set initial rci cycle variables
	RCI_Request = 0;
	successful = 0;

	//rci cycle
	while (successful == 0)
	{
		//cout << "here1";
		/* call tr solver
			handle		in/out:	tr solver handle
			fvec		in:     vector
			fjac		in:     jacobi matrix
			RCI_request in/out:	return number which denote next step for performing */
		if (dtrnlspbc_solve (&handle, fvec, fjac, &RCI_Request) != TR_SUCCESS)
		{
			// Exit if unsuccessful
			cout << "| error in dtrnlspbc_solve\n";
			return -1;
		}

		//Exit if the solution is infeasible

		if ( isnan(x[0]) || isnan(x[1]) || isnan(x[2]) ) {

			// Exit if unsuccessful
			cout << "| Solver returned NAN\n";
			return -2;
		}

		// according with rci_request value we do next step
		if (RCI_Request == -1 ||
			RCI_Request == -2 ||
			RCI_Request == -3 ||
			RCI_Request == -4 ||
			RCI_Request == -5 ||
			RCI_Request == -6)
			// exit rci cycle
			successful = 1;

		if (RCI_Request == 1)
		{
			if (model == "Point" && fit == "HAB")
				Pex_Point_fcn (&m, &n, x, fvec);
			if (model == "Point" && fit == "HoAB")
				Pex_PointOx_fcn (&m, &n, x, fvec);
			else if (model == "Cylinder")
				Pex_CylinderHAB_fcn (&m, &n, x, fvec);
			else if (model == "Sphere")
				Pex_SphereHAB_fcn (&m, &n, x, fvec);

			for (i = 0; i < m; i++) {
				fvec[i] = fvec[i] - fobs[i];

			}
		}
		if (RCI_Request == 2)
		{

			if (model == "Point" && fit == "HAB") {
				if (djacobi (Pex_Point_fcn , &n, &m, fjac, x, eps) != TR_SUCCESS)
				{
					cout << "error in djacobi\n";
					MKL_FreeBuffers();
					return 1;
				}
			}
			if (model == "Point" && fit == "HoAB") {
				if (djacobi (Pex_PointOx_fcn , &n, &m, fjac, x, eps) != TR_SUCCESS)
				{
					cout << "error in djacobi\n";
					MKL_FreeBuffers();
					return 1;
				}
			}
			if (model == "Cylinder") {
				if (djacobi (Pex_CylinderHAB_fcn , &n, &m, fjac, x, eps) != TR_SUCCESS)
				{
					cout << "error in djacobi\n";
					MKL_FreeBuffers();
					return 1;
				}
			}
			if (model == "Sphere") {
				if (djacobi (Pex_SphereHAB_fcn , &n, &m, fjac, x, eps) != TR_SUCCESS)
				{
					cout << "error in djacobi\n";
					MKL_FreeBuffers();
					return 1;
				}
			}
		}
	}

	/* get solution statuses
		handle            in:	TR solver handle
		iter              out:	number of iterations
		st_cr             out:	number of stop criterion
		r1                out:	initial residuals
		r2                out:	final residuals */
	if (dtrnlspbc_get (&handle, &iter, &st_cr, &r1, &r2) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_get\n";
		return -1;
	}

	//******************End of Solve for the best height, A, and B****************************

	//Check to see if the solution is better than previous multi-start solutions
	H = x[0];
	A = x[1];
	B = x[2];
	R = r2;

	/* free allocated memory */
	delete [] x;
	delete [] fvec;
	delete [] fjac;
	delete [] fobs;
	delete [] LW;
	delete [] UP;

	// free handle memory
	if (dtrnlspbc_delete (&handle) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_delete\n";
		return -1;
	}

	return 1;  //successful
}


int nlsq_FLIC_HABL_pixelNC (double* Images, int pixel, int nrows, int ncols, int nimages, double& H, double& A, double& B, double &L, double& R, double h_LB, double h_UB)
{
	//***********************************Variables, etc*******************************************
	MKL_INT n = 4;			//number of function variables (height of pixel, A, B, L)
	MKL_INT m = nimages;	//dimension of function value (number of equations)
	double	eps[6];			// precisions for stop-criteria (see manual for more details)
	double	*x;				// solution vector. contains values x for f(x)
	MKL_INT	iter1 = 1000;	//maximum number of iterations
	MKL_INT	iter2 = 100;	//maximum number of iterations of calculation of trial-step
	double	rs = 0.0;		//initial step bound
	MKL_INT RCI_Request;	//reverse communication interface parameter
	MKL_INT successful;		//controls of rci cycle
	double *fvec;			//function (f(x)) value vector
	double *fobs;			//The observed value for each function
	double *fjac;			//jacobi matrix
	double	*LW, *UP;		//lower and upper bounds
	MKL_INT iter;			//number of iterations
	MKL_INT st_cr;			//number of stop-criterion
	double r1, r2;			//initial and final residuals
	_TRNSPBC_HANDLE_t handle;	//TR solver handle
	int NN_row [9];  	//Storage of the row numbers of nearest neighbor pixels
	int NN_col [9];		//Storage of column numbers of nearest neighbor pixels
	int num_NN;				//The number of neighbors for a given pixel
	MKL_INT row, col, i, j, k;		//counters


	//memory allocation
	x = new double[n];
	fvec = new double[m];
	fobs = new double[m];
	fjac = new double[m*n];
	LW = new double[n];
	UP = new double[n];

	//set precisions for stop-criteria
	for (i = 0; i < 6; i++)
	{
		eps [i] = 0.0000001;
	}

	//set bounds
	LW [0] = h_LB;
	LW [1] = A_min;
	LW [2] = B_min;
	LW [3] = L_min;
	UP [0] = h_UB;
	UP [1] = A_max;
	UP [2] = B_max;
	UP [3] = L_max;


	//Loop through all the pixels and calculate the best estimate of the height for each pixel
	row = getRow(pixel, ncols);
	col = getCol(pixel, ncols);

	//Get the nearest neighbor pixels
	num_NN = getNeighbors(NN_row, NN_col, row, col, 0, nrows, ncols);

	//Compute fobs
	for (i = 0; i < num_angles; i++) {
		fobs[i] = 0.0;
		for (j = 0; j < num_NN; j++) {
			fobs[i] = fobs[i] + Images[getIndex(NN_row[j], NN_col[j], i, nrows, ncols)];
		}
		fobs[i] = fobs[i]/num_NN;
	}

	//Set the initial guess
	x[0] = H;
	x[1] = A_guess;
	x[2] = B_guess;
	x[3] = L_guess;

	//set initial values
	for (i = 0; i < m; i++)
		fvec [i] = 0.0;
	for (i = 0; i < m*n; i++)
		fjac [i] = 0.0;


	//***********************Solve for the best height, A, and B********************************

	/* initialize solver (allocate mamory, set initial values)
		handle	in/out:	TR solver handle
		n       in:     number of function variables
		m       in:     dimension of function value
		x       in:     solution vector. contains values x for f(x)
		LW		in:		lower bound
		UP		in:		upper bound
		eps     in:     precisions for stop-criteria
		iter1   in:     maximum number of iterations
		iter2   in:     maximum number of iterations of calculation of trial-step
		rs      in:     initial step bound */
	if (dtrnlspbc_init (&handle, &n, &m, x, LW, UP, eps, &iter1, &iter2, &rs) !=
		TR_SUCCESS)
	{
		// Exit if unsuccessful
		cout << "| error in dtrnlspbc_init\n";
		return 0;
	}

	//set initial rci cycle variables
	RCI_Request = 0;
	successful = 0;

	//rci cycle
	while (successful == 0)
	{
		//cout << "here1";
		/* call tr solver
			handle		in/out:	tr solver handle
			fvec		in:     vector
			fjac		in:     jacobi matrix
			RCI_request in/out:	return number which denote next step for performing */
		if (dtrnlspbc_solve (&handle, fvec, fjac, &RCI_Request) != TR_SUCCESS)
		{
			// Exit if unsuccessful
			cout << "| error in dtrnlspbc_solve\n";
			return -1;
		}

		//Exit if the solution is infeasible

		if ( isnan(x[0]) || isnan(x[1]) || isnan(x[2]) ) {

			// Exit if unsuccessful
			cout << "| Solver returned NAN\n";
			return -2;
		}

		// according with rci_request value we do next step
		if (RCI_Request == -1 ||
			RCI_Request == -2 ||
			RCI_Request == -3 ||
			RCI_Request == -4 ||
			RCI_Request == -5 ||
			RCI_Request == -6)
			// exit rci cycle
			successful = 1;

		if (RCI_Request == 1)
		{
			if (model == "Cylinder")
				Pex_CylinderHABL_fcn (&m, &n, x, fvec);
			else if (model == "Sphere")
				Pex_SphereHABL_fcn (&m, &n, x, fvec);

			for (i = 0; i < m; i++) {
				fvec[i] = fvec[i] - fobs[i];

			}
		}
		if (RCI_Request == 2)
		{
			if (model == "Cylinder") {
				if (djacobi (Pex_CylinderHABL_fcn , &n, &m, fjac, x, eps) != TR_SUCCESS)
				{
					cout << "error in djacobi\n";
					MKL_FreeBuffers();
					return 1;
				}
			}
			if (model == "Sphere") {
				if (djacobi (Pex_SphereHABL_fcn , &n, &m, fjac, x, eps) != TR_SUCCESS)
				{
					cout << "error in djacobi\n";
					MKL_FreeBuffers();
					return 1;
				}
			}
		}
	}

	/* get solution statuses
		handle            in:	TR solver handle
		iter              out:	number of iterations
		st_cr             out:	number of stop criterion
		r1                out:	initial residuals
		r2                out:	final residuals */
	if (dtrnlspbc_get (&handle, &iter, &st_cr, &r1, &r2) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_get\n";
		return -1;
	}

	//******************End of Solve for the best height, A, and B****************************

	//Check to see if the solution is better than previous multi-start solutions
	H = x[0];
	A = x[1];
	B = x[2];
	L = x[3];
	R = r2;

	/* free allocated memory */
	delete [] x;
	delete [] fvec;
	delete [] fjac;
	delete [] fobs;
	delete [] LW;
	delete [] UP;

	// free handle memory
	if (dtrnlspbc_delete (&handle) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_delete\n";
		return -1;
	}

	return 1;  //successful
}

//	#pragma omp parallel shared(n,m,eps,LW,UP,iter1,iter2,rs) private(x,RCI_Request,successful,fvec,fobs,fjac,iter,st_cr,r1,r2,handle,NN_row,NN_col,num_NN,row,col,i,j,k,h_best,A_best,B_best,r_min,r1_min,MS_start)
//	#pragma omp for

//Fcn for jacobi for NC method
void Pex_Point_fcn (MKL_INT *m, MKL_INT *n, double *x, double *f) {
	for (int i = 0; i < *m; i++) {
		f[i] = x[1]*P_Ex(thetaLaser[i], lambdaEx, x[0]) + x[2];
		//cout << ".";
	}
}

void Pex_PointOx_fcn (MKL_INT *m, MKL_INT *n, double *x, double *f) {
	for (int i = 0; i < *m; i++) {
		d1 = x[0];
		f[i] = x[1]*P_Ex(thetaLaser[i], lambdaEx, 0) + x[2];
	}
}

void Pex_CylinderHAB_fcn (MKL_INT *m, MKL_INT *n, double *x, double *f) {
	for (int i = 0; i < *m; i++) {
		//f[i] = x[1]*Pex_Simple_thetaEx_H(thetaLaser[i], lambdaEx, x[0]-0.5*length, x[0]+0.5*length) + x[2];
	}
}

void Pex_SphereHAB_fcn (MKL_INT *m, MKL_INT *n, double *x, double *f) {
	for (int i = 0; i < *m; i++) {
		//f[i] = x[1]*Pex_Simple_Sphere_r_alpha_psi(thetaLaser[i], 0, PI, lambdaEx, x[0], radius) + x[2];
	}
}

void Pex_CylinderHABL_fcn (MKL_INT *m, MKL_INT *n, double *x, double *f) {
	for (int i = 0; i < *m; i++) {
		f[i] = x[1]*P_Ex_Cylinder (thetaLaser[i], lambdaEx, x[0]-0.5*x[3], x[0]+0.5*x[3])/x[3] + x[2];
		//f[i] = x[1]*P_Ex_Distribution (thetaLaser[i], lambdaEx, x[0], x[3]) + x[2];  //Note L here is sigma squared
	}
}

void Pex_SphereHABL_fcn (MKL_INT *m, MKL_INT *n, double *x, double *f) {
	for (int i = 0; i < *m; i++) {
		//f[i] = x[1]*Pex_Simple_Sphere_r_alpha_psi(thetaLaser[i], 0, PI, lambdaEx, x[0], x[3])/(4/3*PI*x[3]*x[3]*x[3]) + x[2];
	}
}



int FLIC_fitter_Brute (double* Images, int* pixels, int npix, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double* H, double A, double B, double* R)
{
	//***********************************Variables, etc*******************************************
	int i, j, k, row, col;		//iterators
	int num_NN;				//the number of nearest neighbors for a given pixel
	int NN_row [9];			//the row numbers of the nearest neighbors
	int NN_col [9];			//the column numbers of the nearest neighbors
	double *fobs =
		new double[nimages];	//the observed data
	double r;				//the residual
	double r_min;			//the minimum residual found
	double h_best;			//the height for a pixel with the lowest residual

	//Loop through all the pixels and calculate the best estimate of the height for each pixel
	for (k = 0; k < npix; k++) {

		row = getRow(pixels[k], ncols);
		col = getCol(pixels[k], ncols);

		//Get the nearest neighbor pixels
		num_NN = getNeighbors(NN_row, NN_col, row, col, 0, nrows, ncols);

		//Compute fobs
		for (i = 0; i < num_angles; i++) {
			fobs[i] = 0.0;
			for (j = 0; j < num_NN; j++) {
				fobs[i] = fobs[i] + Images[getIndex(NN_row[j], NN_col[j], i, nrows, ncols)];
			}
			fobs[i] = fobs[i]/num_NN;
		}

		//Find the best height for each pixel with brute force
		r_min = numeric_limits<double>::infinity();

		for (j = 0; ZGAP[j] < H_max; j++) {

			//Compute the residual
			r = 0.0;
			for (i = 0; i < nimages; i++) {
				r = r + (A*FLIC[i*FLIC_points + j] + B - fobs[i])*(A*FLIC[i*FLIC_points + j] + B - fobs[i]);
			}

			//Check to see if the solution is better than previous multi-start solutions
			if (r < r_min) {
				h_best = ZGAP[j];
				r_min = r;
			}
		}
		H[ getIndex(row, col, 0, nrows, ncols) ] = h_best;
		R[ getIndex(row, col, 0, nrows, ncols) ] = r_min;
	}

	delete [] fobs;
	return 1;
}


int FLIC_fitter_BruteT (double* Images, int* pixels, int npix, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double* H, double A, double B, double* R)
{
	//***********************************Variables, etc*******************************************
	int i, j, k, row, col;		//iterators
	int num_NN;				//the number of nearest neighbors for a given pixel
	int NN_row [9];			//the row numbers of the nearest neighbors
	int NN_col [9];			//the column numbers of the nearest neighbors
	double *fobs;			//the observed data
	double r;				//the residual
	double r_min;			//the minimum residual found
	double h_best;			//the height for a pixel with the lowest residual

	//Loop through all the pixels and calculate the best estimate of the height for each pixel

	#pragma omp parallel private(i,j,k,row,col,num_NN,NN_row,NN_col,fobs,r,r_min,h_best)
	{
		fobs = new double[nimages];

		#pragma omp for
		for (k = 0; k < npix; k++) {

			row = getRow(pixels[k], ncols);
			col = getCol(pixels[k], ncols);

			//Get the nearest neighbor pixels
			num_NN = getNeighbors(NN_row, NN_col, row, col, 0, nrows, ncols);

			//Compute fobs
			for (i = 0; i < num_angles; i++) {
				fobs[i] = 0.0;
				for (j = 0; j < num_NN; j++) {
					fobs[i] = fobs[i] + Images[getIndex(NN_row[j], NN_col[j], i, nrows, ncols)];
				}
				fobs[i] = fobs[i]/num_NN;
			}

			//Find the best height for each pixel with brute force
			r_min = numeric_limits<double>::infinity();

			for (j = 0; ZGAP[j] < H_max; j++) {

				//Compute the residual
				r = 0.0;
				for (i = 0; i < nimages; i++) {
					r = r + (A*FLIC[i*FLIC_points + j] + B - fobs[i])*(A*FLIC[i*FLIC_points + j] + B - fobs[i]);
				}

				//Check to see if the solution is better than previous multi-start solutions
				if (r < r_min) {
					h_best = ZGAP[j];
					r_min = r;
				}
			}

			H[ getIndex(row, col, 0, nrows, ncols) ] = h_best;
			R[ getIndex(row, col, 0, nrows, ncols) ] = r_min;
		}

		delete [] fobs;

	} //#pragma omp parallel shared() private()

	return 1;
}

//fjac = df1/dx1, df2/dx1, df3/dx1, df4/dx1, df1/dx2, df2/dx2, df2/dx3, df2/dx4,...
/* 	nonlinear least square problem with boundary constraints

	Variables
	images	in:	TR solver handle
	heights out:     solution vector.  con	if ( (startRow - dist < 0) && (startRow + dist >= nrows) && (startCol - dist < 0) && (startCol + dist >= ncols) && (dist >= 4)) {
		return 1;  //exit successful - All pixels processed
	}tains height of each pixel
	A       out:     solution for scaling factor A
	B       out:     solution for background parameter B
*/

int nlsq_FLIC_HAB_global (double* Images, int* pixels, int npix, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double* H, double& A, double& B, double& R)
{
	//***********************************Variables, etc*******************************************
	MKL_INT n = npix+2;			//number of function variables (height of pixel, A, B)
	MKL_INT m = npix*nimages;	//dimension of function value (number of equations)
	double	eps[6];			// precisions for stop-criteria (see manual for more details
	double	*x;				// solution vector. contains values x for f(x)
	MKL_INT	iter1 = 1000;	//maximum number of iterations
	MKL_INT	iter2 = 100;	//maximum number of iterations of calculation of trial-step
	double	rs = 0.0;		//initial step bound
	MKL_INT RCI_Request;	//reverse communication interface parameter
	MKL_INT successful;		//controls of rci cycle
	double *fvec;			//function (f(x)) value vector
	double *fobs;			//The observed value for each function
	double *fjac;			//jacobi matrix
	double	*LW, *UP;		//lower and upper bounds
	MKL_INT iter;			//number of iterations
	MKL_INT st_cr;			//number of stop-criterion
	double r1, r2;			//initial and final residuals
	_TRNSPBC_HANDLE_t handle;	//TR solver hand		le
	MKL_INT row, col, i, j, k;		//counters
	double h_best, A_best, B_best;	//The best multi-start solution for h, A, and B
	int counter;


	//memory allocation
	x = new double[n];
	fvec = new double[m];
	fobs = new double[m];
	fjac = new double[m*n];
	LW = new double[n];
	UP = new double[n];

	//set precisions for stop-criteria
	for (i = 0; i < 6; i++)
	{
		eps [i] = 0.0000001;
	}

	//set bounds
	for (i = 0; i < npix; i++) {
		LW [i] = H_min;
		UP [i] = H_max;
	}
	LW [npix] 	= A_min;
	LW [npix+1] = B_min;
	UP [npix] 	= A_max;
	UP [npix+1] = B_max;

	//Set the initial guess
	for (i = 0; i < npix; i++) x[i] = H[ pixels[i] ];
	x[npix]   = A;
	x[npix+1] = B;

	cout << "AB: " << A << " " << B;

	//set initial values
	for (i = 0; i < m; i++)
		fvec [i] = 0.0;
	for (i = 0; i < m*n; i++)
		fjac [i] = 0.0;

	//Set fobs
	counter = 0;
	for (i = 0; i < npix; i++) {
		row = getRow(pixels[i], ncols);
		col = getCol(pixels[i], ncols);
		for (j = 0; j < nimages; j++) {
			fobs[counter] = Images[getIndex(row, col, j, nrows, ncols)];
			counter++;
		}
	}



	//***********************Solve for the best height, A, and B********************************

	/* initialize solver (allocate mamory, set initial values)
		handle	in/out:	TR solver handle
		n       in:     number of function variables
		m       in:     dimension of function value
		x       in:     solution vector. contains values x for f(x)
		LW		in:		lower bound
		UP		in:		upper bound
		eps     in:     precisions for stop-criteria
		iter1   in:     maximum number of iterations
		iter2   in:     maximum number of iterations of calculation of trial-step
		rs      in:     initial step bound */
	if (dtrnlspbc_init (&handle, &n, &m, x, LW, UP, eps, &iter1, &iter2, &rs) != TR_SUCCESS)
	{
		// Exit if unsuccessful
		cout << "| error in dtrnlspbc_init\n";
		MKL_FreeBuffers();
		return 1;
	}

	//set initial rci cycle variables
	RCI_Request = 0;
	successful = 0;

	//rci cycle
	while (successful == 0)
	{
		/* call tr solver
			handle		in/out:	tr solver handle
			fvec		in:     vector
			fjac		in:     jacobi matrix
			RCI_request in/out:	return number which denote next step for performing */
		if (dtrnlspbc_solve (&handle, fvec, fjac, &RCI_Request) != TR_SUCCESS)
		{
			// Exit if unsuccessful
			cout << "| error in dtrnlspbc_solve\n";
			MKL_FreeBuffers();
			return 1;
		}

		// according with rci_request value we do next step
		if (RCI_Request == -1 ||
			RCI_Request == -2 ||
			RCI_Request == -3 ||
			RCI_Request == -4 ||
			RCI_Request == -5 ||
			RCI_Request == -6)
			// exit rci cycle
			successful = 1;

		if (RCI_Request == 1)
		{
			// recalculate function value
			for (i = 0; i < npix; i++) {
				for (j = 0; j < nimages; j++) {
					fvec[i*nimages + j] = x[npix]*interpolateFLIC(ZGAP, &FLIC[j*FLIC_points], zGapSpacing, FLIC_points, x[i]) + x[npix+1] - fobs[i*nimages + j];
				}
			}
		}
		if (RCI_Request == 2)
		{
			// compute jacobi matrix
			//fjac = df1/dx1, df2/dx1, df3/dx1, df4/dx1,..., df1/dx2, df2/dx2, df2/dx2, df2/dx2,...
			for (i = 0; i < npix; i++) {
				for (j = 0; j < nimages; j++) {
					fjac[i*m + i*nimages + j] = x[npix]*interpolateFLIC(ZGAP, &DERIV[j*FLIC_points], zGapSpacing, FLIC_points, x[i]);
					fjac[npix*m + i*nimages + j] = interpolateFLIC(ZGAP, &FLIC[j*FLIC_points], zGapSpacing, FLIC_points, x[i]);
					fjac[(npix+1)*m + i*nimages + j] = 1;
					//fjac[(npix+2)*m + i*nimages + j] = ...;  if dye dipole angle is also fit
				}
			}
		}
	}

	/* get solution statuses
		handle            in:	TR solver handle
		iter              out:	number of iterations
		st_cr             out:	number of stop criterion
		r1                out:	initial residuals
		r2                out:	final residuals */
	if (dtrnlspbc_get (&handle, &iter, &st_cr, &r1, &r2) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_get\n";
		MKL_FreeBuffers();
		return 1;
	}

	// free handle memory
	if (dtrnlspbc_delete (&handle) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_delete\n";
		MKL_FreeBuffers();
		return 1;
	}

	//******************End of Solve for the best height, A, and B****************************

	//Copy the best-fit variables to the output variables
	for (i = 0; i < npix; i++) {
		H[ pixels[i] ] = x[i];
	}
	A = x[npix];
	B = x[npix+1];


	/* free allocated memory */
	delete [] x;
	delete [] fvec;
	delete [] fjac;
	delete [] LW;
	delete [] UP;

	return 1;

}


int nlsq_FLIC_HAB_globalGradient (double* Images, int* dataPixels, int ndataPix, int nrows, int ncols, int nimages, double* ZGAP,
		double* FLIC, double* DERIV, double* H, double& A, double& B, double& R, double str)
{
	//***********************************Variables, etc*******************************************
	MKL_INT ngrid = (nrows-2)*(ncols-2);  //The number of points on the grid for the finite difference method
	MKL_INT npix = nrows*ncols;	//The total number of pixels in the images
	MKL_INT n = npix+2;			//number of function variables (height of pixel, A, B)
	MKL_INT m = ndataPix*nimages + 2*ngrid;	//dimension of function value (number of equations)
	double	eps[6];			// precisions for stop-criteria (see manual for more details
	double	*x;				// solution vector. contains values x for f(x)
	MKL_INT	iter1 = 1000;	//maximum number of iterations
	MKL_INT	iter2 = 100;	//maximum number of iterations of calculation of trial-step
	double	rs = 0.0;		//initial step bound
	MKL_INT RCI_Request;	//reverse communication interface parameter
	MKL_INT successful;		//controls of rci cycle
	double *fvec;			//function (f(x)) value vector
	double *fobs;			//The observed value for each function
	double *fjac;			//jacobi matrix
	double	*LW, *UP;		//lower and upper bounds
	MKL_INT iter;			//number of iterations
	MKL_INT st_cr;			//number of stop-criterion
	double r1, r2;			//initial and final residuals
	_TRNSPBC_HANDLE_t handle;	//TR solver handle
	MKL_INT row, col, i, j, k;		//counters
	double h_best, A_best, B_best;	//The best multi-start solution for h, A, and B
	int counter;
	MKL_INT indImage, indGrid;



	//memory allocation
	x = new double[n];
	fvec = new double[m];
	fobs = new double[m];
	fjac = new double[m*n];
	LW = new double[n];
	UP = new double[n];

	//set precisions for stop-criteria
	for (i = 0; i < 6; i++)
	{
		eps [i] = 0.0000001;
	}

	//set bounds
	for (i = 0; i < npix; i++) {
		LW [i] = H_min;
		UP [i] = H_max;
	}
	LW [npix] 	= A_min;
	LW [npix+1] = B_min;
	UP [npix] 	= A_max;
	UP [npix+1] = B_max;

	//Set the initial guess
	for (i = 0; i < npix; i++) x[i] = H[i];
	x[npix]   = A;
	x[npix+1] = B;

	cout << "AB: " << A << " " << B;

	//set initial values
	for (i = 0; i < m; i++)
		fvec [i] = 0.0;
	for (i = 0; i < m*n; i++)
		fjac [i] = 0.0;

	//Set fobs - FLIC data
	counter = 0;
	for (i = 0; i < ndataPix; i++) {
		row = getRow(dataPixels[i], ncols);
		col = getCol(dataPixels[i], ncols);
		for (j = 0; j < nimages; j++) {
			fobs[counter] = Images[getIndex(row, col, j, nrows, ncols)];
			counter++;
		}
	}
	//set fobs - Gradient regularizer -  These equations are set to zero
	for (i = counter; i < m; i++) {
		fobs[i] = 0.0;
	}



	//***********************Solve for the best height, A, and B********************************

	// initialize solver (allocate mamory, set initial values)
	if (dtrnlspbc_init (&handle, &n, &m, x, LW, UP, eps, &iter1, &iter2, &rs) != TR_SUCCESS)
	{
		// Exit if unsuccessful
		cout << "| error in dtrnlspbc_init\n";
		MKL_FreeBuffers();
		return 1;
	}

	//set initial rci cycle variables
	RCI_Request = 0;
	successful = 0;

	//rci cycle
	while (successful == 0)
	{
		//call tr solver
		if (dtrnlspbc_solve (&handle, fvec, fjac, &RCI_Request) != TR_SUCCESS)
		{
			// Exit if unsuccessful
			cout << "| error in dtrnlspbc_solve\n";
			MKL_FreeBuffers();
			return 1;
		}
		cout << "\nRequest: " << RCI_Request;
		// according with rci_request value we do next step
		if (RCI_Request == -1 ||
			RCI_Request == -2 ||
			RCI_Request == -3 ||
			RCI_Request == -4 ||
			RCI_Request == -5 ||
			RCI_Request == -6)
			// exit rci cycle
			successful = 1;

		if (RCI_Request == 1)  //Calculate fxn values
		{
			// recalculate function value - Equations for FLIC data
			//#pragma omp parallel for private(i,j)
			for (i = 0; i < ndataPix; i++) {
				for (j = 0; j < nimages; j++) {
					fvec[i*nimages + j] = x[npix]*interpolateFLIC(ZGAP, &FLIC[j*FLIC_points], zGapSpacing, FLIC_points, x[dataPixels[i]]) + x[npix+1] - fobs[i*nimages + j];
				}
			}

			//Equations for regularizer - d2u/dy2
			//#pragma omp parallel for private(row,col)
			for (col = 1; col < ncols-1; col++) {
				for (row = 1; row < nrows-1; row++) {

					indGrid = getIndex(row, col, 0, nrows-2, ncols-2);

					fvec[ndataPix*nimages + indGrid] = -2*str*nimages*x[ getIndex(row, col, 0, nrows, ncols) ] + str*nimages*x[ getIndex(row+1, col, 0, nrows, ncols)] +
							str*nimages*x[ getIndex(row-1, col, 0, nrows, ncols)];

				}
			}

			//Equations for regularizer - d2u/dx2
			//#pragma omp parallel for private(row,col)
			for (col = 1; col < ncols-1; col++) {
				for (row = 1; row < nrows-1; row++) {

					indGrid = getIndex(row, col, 0, nrows-2, ncols-2);

					fvec[ndataPix*nimages + ngrid + indGrid] = -2*str*nimages*x[ getIndex(row, col, 0, nrows, ncols) ] + str*nimages*x[ getIndex(row, col+1, 0, nrows, ncols)] +
							str*nimages*x[ getIndex(row, col-1, 0, nrows, ncols)];

				}
			}
		}

		if (RCI_Request == 2)
		{
			// compute jacobi matrix
			//fjac = df1/dx1, df2/dx1, df3/dx1, df4/dx1,..., df1/dx2, df2/dx2, df3/dx2, df4/dx2,...
			//#pragma omp parallel for private(row,col)
			for (i = 0; i < ndataPix; i++) {
				for (j = 0; j < nimages; j++) {
					fjac[dataPixels[i]*m + i*nimages + j] = x[npix]*interpolateFLIC(ZGAP, &DERIV[j*FLIC_points], zGapSpacing, FLIC_points, x[ dataPixels[i] ]);
					fjac[npix*m + i*nimages + j] = interpolateFLIC(ZGAP, &FLIC[j*FLIC_points], zGapSpacing, FLIC_points, x[ dataPixels[i] ]);
					fjac[(npix+1)*m + i*nimages + j] = 1;
				}
			}

			//jacobi for regularizer - d2u/dy2
			//#pragma omp parallel for private(row,col)
			for (col = 1; col < ncols-1; col++) {
				for (row = 1; row < nrows-1; row++) {

					indGrid = getIndex(row, col, 0, nrows-2, ncols-2);

					indImage = getIndex(row, col, 0, nrows, ncols);
					fjac[m*indImage + ndataPix*nimages + indGrid] = -2*str*nimages;

					indImage = getIndex(row-1, col, 0, nrows, ncols);
					fjac[m*indImage + ndataPix*nimages + indGrid] = str*nimages;

					indImage = getIndex(row+1, col, 0, nrows, ncols);
					fjac[m*indImage + ndataPix*nimages + indGrid] = str*nimages;
				}
			}

			//jacobi for regularizer - d2u/dy2
			//#pragma omp parallel for private(row,col)
			for (col = 1; col < ncols-1; col++) {
				for (row = 1; row < nrows-1; row++) {

					indGrid = getIndex(row, col, 0, nrows-2, ncols-2);

					indImage = getIndex(row, col, 0, nrows, ncols);
					fjac[m*indImage + ndataPix*nimages + ngrid + indGrid] = -2*str*nimages;

					indImage = getIndex(row, col-1, 0, nrows, ncols);
					fjac[m*indImage + ndataPix*nimages + ngrid + indGrid] = str*nimages;

					indImage = getIndex(row, col+1, 0, nrows, ncols);
					fjac[m*indImage + ndataPix*nimages + ngrid + indGrid] = str*nimages;
				}
			}
			cout << "\nfinished calculating fvec";
		}


	}

	// get solution statuses
	if (dtrnlspbc_get (&handle, &iter, &st_cr, &r1, &r2) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_get\n";
		MKL_FreeBuffers();
		return 1;
	}

	// free handle memory
	if (dtrnlspbc_delete (&handle) != TR_SUCCESS)
	{
		//exit if unsuccessful
		cout << "| error in dtrnlspbc_delete\n";
		MKL_FreeBuffers();
		return 1;
	}

	//******************End of Solve for the best height, A, and B****************************

	//Copy the best-fit variables to the output variables
	for (i = 0; i < npix; i++) {
		H[i] = x[i];
	}
	A = x[npix];
	B = x[npix+1];
	R = r2;


	// free allocated memory
	delete [] x;
	delete [] fvec;
	delete [] fjac;
	delete [] LW;
	delete [] UP;

	return 1;

}

